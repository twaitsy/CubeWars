// =============================================================
// TurretProjectile.cs
//
// DEPENDENCIES:
// - TurretProjectilePool:
//      * Spawns and despawns this projectile.
// - Attackable (MonoBehaviour):
//      * Used to apply damage on impact (via TakeDamage or similar).
//
// NOTES FOR FUTURE MAINTENANCE:
// - Right now this is a standalone projectile system, separate from the
//   Projectile used by UnitCombatController.
// - If you want turrets to use this instead of the generic Projectile,
//   wire Turret / UnitCombatController to spawn TurretProjectile via the pool.
// - Ensure Attackable has a damage API compatible with this script.
// =============================================================

using UnityEngine;

public class TurretProjectile : MonoBehaviour
{
    [HideInInspector] public TurretProjectile prefabKey;

    private Transform target;
    private float damage;
    private float speed;
    private float life;
    private int ownerTeamID;

    /// <summary>
    /// Initialize the projectile.
    /// </summary>
    public void Init(int ownerTeamID, Transform targetTf, float dmg, float spd)
    {
        this.ownerTeamID = ownerTeamID;
        target = targetTf;
        damage = dmg;
        speed = spd;
        life = 2.0f;
    }

    void Update()
    {
        life -= Time.deltaTime;
        if (life <= 0f)
        {
            TurretProjectilePool.Instance.Despawn(this);
            return;
        }

        if (target == null)
        {
            TurretProjectilePool.Instance.Despawn(this);
            return;
        }

        Vector3 dir = target.position - transform.position;
        float dist = dir.magnitude;

        if (dist < 0.25f)
        {
            // Apply damage on impact if target has an Attackable component.
            var atk = target.GetComponentInParent<Attackable>();
            if (atk != null && atk.IsAlive && atk.teamID != ownerTeamID)
            {
                atk.TakeDamage(damage);
            }

            TurretProjectilePool.Instance.Despawn(this);
            return;
        }

        transform.position += dir.normalized * (speed * Time.deltaTime);
        transform.forward = dir.normalized;
    }
}