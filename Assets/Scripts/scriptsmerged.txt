

==============================
FILE: NewBehaviourScript.cs
==============================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}


==============================
FILE: EventManager.cs
==============================

using UnityEngine;

public class EventManager : MonoBehaviour
{
    // This will eventually handle scripted events,
    // campaign triggers, waves, and timed missions.

    void Awake()
    {
        Debug.Log("EventManager initialized");
    }
}

==============================
FILE: GameBootstrap.cs
==============================

using UnityEngine;

public class GameBootstrap : MonoBehaviour
{
    [Header("Prefabs")]
    public GameObject uiPrefab;
    public GameObject cameraRigPrefab;

    void Awake()
    {
        DontDestroyOnLoad(gameObject);

        // ROOTS
        GameObject worldRoot = new GameObject("World");
        GameObject systemsRoot = new GameObject("Systems");
        GameObject teamsRoot = new GameObject("Teams");

        // WORLD SUBROOTS
        new GameObject("Terrain").transform.SetParent(worldRoot.transform);
        new GameObject("ResourceNodes").transform.SetParent(worldRoot.transform);
        new GameObject("NeutralFactions").transform.SetParent(worldRoot.transform);
        new GameObject("MapBounds").transform.SetParent(worldRoot.transform);

        // TEAMS
        for (int i = 1; i <= 8; i++)
        {
            GameObject team = new GameObject($"Team_{i}");
            team.transform.SetParent(teamsRoot.transform);

            new GameObject("HQ").transform.SetParent(team.transform);
            new GameObject("Units").transform.SetParent(team.transform);
            new GameObject("Buildings").transform.SetParent(team.transform);
        }

        // SYSTEMS (created at runtime)
        CreateSystem<BuildGridManager>(systemsRoot);
        CreateSystem<BuildPlacementManager>(systemsRoot);
        CreateSystem<ConstructionManager>(systemsRoot);
        CreateSystem<TeamResources>(systemsRoot);
        CreateSystem<JobManager>(systemsRoot);
        CreateSystem<AIManager>(systemsRoot);
        CreateSystem<CombatManager>(systemsRoot);
        CreateSystem<ProjectilePool>(systemsRoot);
        CreateSystem<UnitManager>(systemsRoot);
        CreateSystem<EventManager>(systemsRoot);
        CreateSystem<WinConditionManager>(systemsRoot);

        // GAME MANAGER
        CreateSystem<GameManager>(null);

        // UI + CAMERA
        Instantiate(uiPrefab).name = "UI";
        Instantiate(cameraRigPrefab).name = "CameraRig";
    }

    void CreateSystem<T>(GameObject parent) where T : Component
    {
        GameObject obj = new GameObject(typeof(T).Name);
        obj.AddComponent<T>();
        if (parent != null)
            obj.transform.SetParent(parent.transform);
    }
}

==============================
FILE: HQSpawner.cs
==============================

using UnityEngine;

/// <summary>
/// Spawns an HQ for every Team in the scene that does not already have one.
/// This is a lightweight bootstrap component that ONLY handles HQ spawning.
/// It does NOT spawn UI, camera, systems, or anything else.
/// </summary>
public class HQSpawner : MonoBehaviour
{
    [Header("HQ Prefab")]
    [Tooltip("The HQ building prefab that will be spawned for each team.")]
    public GameObject hqPrefab;

    [Header("Spawn Settings")]
    [Tooltip("Optional offset applied when spawning HQs. Useful if HQRoot is at 0,0,0.")]
    public Vector3 spawnOffset = Vector3.zero;

    void Start()
    {
        // Find all Team components in the scene
        Team[] teams = FindObjectsOfType<Team>();

        foreach (var team in teams)
        {
            // --- SAFETY CHECK 1: Ensure the team has an HQ root ---
            if (team.hqRoot == null)
            {
                Debug.LogWarning(
                    $"Team {team.teamID} has no HQ root child object. " +
                    $"Expected: Team_X -> HQ. Skipping HQ spawn."
                );
                continue;
            }

            // --- SAFETY CHECK 2: Skip if HQ already exists ---
            if (team.hqRoot.childCount > 0)
            {
                // HQ already placed manually or by another system
                continue;
            }

            // --- SPAWN HQ ---
            Vector3 spawnPos = team.hqRoot.position + spawnOffset;
            GameObject hq = Instantiate(hqPrefab, spawnPos, Quaternion.identity);

            // Parent under the HQ root for clean hierarchy
            hq.transform.SetParent(team.hqRoot);

            // --- ASSIGN TEAM OWNERSHIP ---
            // Headquarters inherits from Building, so we assign teamID via Building
            Building building = hq.GetComponent<Building>();
            if (building != null)
            {
                building.teamID = team.teamID;
            }
            else
            {
                Debug.LogWarning(
                    $"HQ prefab '{hqPrefab.name}' has no Building component. " +
                    $"Cannot assign team ownership."
                );
            }

            Debug.Log($"Spawned HQ for Team {team.teamID}");
        }
    }
}

==============================
FILE: RTSCamera.cs
==============================

using UnityEngine;

public class RTSCamera : MonoBehaviour
{
    [Header("Keyboard Pan (WASD)")]
    public float keyboardPanSpeed = 20f;

    [Header("Mouse Wheel Zoom")]
    public float zoomSensitivity = 25f;
    public float minY = 10f;
    public float maxY = 60f;

    [Header("Edge Scrolling")]
    public bool edgeScrollEnabled = true;
    public float edgeBorderPixels = 18f;
    public float edgeScrollSpeed = 22f;

    [Header("Right Click Rotate (Spin)")]
    public bool rightClickRotateEnabled = true;
    public float rightClickYawSensitivity = 0.25f;

    [Header("Middle Click Drag Pan")]
    public bool middleClickDragEnabled = true;
    public float middleDragPanSensitivity = 0.02f;

    [Header("Optional Rotate Keys (Q/E)")]
    public bool enableQE = false;
    public float rotateKeySpeed = 120f;

    [Header("Optional Map Bounds")]
    public bool clampToBounds = false;
    public float minX = -200f;
    public float maxX = 200f;
    public float minZ = -200f;
    public float maxZ = 200f;

    private bool isRotating;
    private bool isDragging;
    private Vector3 lastMousePos;
    private float targetY;

    void Start()
    {
        targetY = transform.position.y;
    }

    void Update()
    {
        Vector3 pos = transform.position;

        // Update flat movement basis only when not rotating
        Vector3 flatForward = Vector3.ProjectOnPlane(transform.forward, Vector3.up).normalized;
        Vector3 flatRight = Vector3.ProjectOnPlane(transform.right, Vector3.up).normalized;

        // RMB rotate
        if (rightClickRotateEnabled)
        {
            if (Input.GetMouseButtonDown(1))
            {
                isRotating = true;
                lastMousePos = Input.mousePosition;
            }
            if (Input.GetMouseButtonUp(1)) isRotating = false;

            if (isRotating)
            {
                Vector3 delta = Input.mousePosition - lastMousePos;
                lastMousePos = Input.mousePosition;

                float yawDegrees = delta.x * rightClickYawSensitivity;
                transform.Rotate(Vector3.up, yawDegrees, Space.World);

                flatForward = Vector3.ProjectOnPlane(transform.forward, Vector3.up).normalized;
                flatRight = Vector3.ProjectOnPlane(transform.right, Vector3.up).normalized;
            }
        }

        // MMB drag pan
        if (middleClickDragEnabled)
        {
            if (Input.GetMouseButtonDown(2))
            {
                isDragging = true;
                lastMousePos = Input.mousePosition;
            }
            if (Input.GetMouseButtonUp(2)) isDragging = false;

            if (isDragging)
            {
                Vector3 delta = Input.mousePosition - lastMousePos;
                lastMousePos = Input.mousePosition;

                float heightScale = Mathf.Clamp01((pos.y - minY) / Mathf.Max(0.001f, (maxY - minY)));
                float scaledSensitivity = middleDragPanSensitivity * Mathf.Lerp(0.75f, 2.0f, heightScale);

                Vector3 dragMove = (-flatRight * delta.x + -flatForward * delta.y) * scaledSensitivity;
                pos += dragMove;
            }
        }

        // Keyboard pan
        Vector3 panVel = Vector3.zero;
        float x = 0f, z = 0f;

        if (Input.GetKey(KeyCode.A) || Input.GetKey(KeyCode.LeftArrow)) x -= 1f;
        if (Input.GetKey(KeyCode.D) || Input.GetKey(KeyCode.RightArrow)) x += 1f;
        if (Input.GetKey(KeyCode.W) || Input.GetKey(KeyCode.UpArrow)) z += 1f;
        if (Input.GetKey(KeyCode.S) || Input.GetKey(KeyCode.DownArrow)) z -= 1f;

        if (Mathf.Abs(x) > 0.01f || Mathf.Abs(z) > 0.01f)
        {
            Vector3 kb = (flatRight * x + flatForward * z).normalized;
            panVel += kb * keyboardPanSpeed;
        }

        // Edge scrolling
        if (edgeScrollEnabled && !isDragging && !isRotating)
        {
            Vector3 mp = Input.mousePosition;
            Vector3 edgeDir = Vector3.zero;

            if (mp.x <= edgeBorderPixels) edgeDir += -flatRight;
            if (mp.x >= Screen.width - edgeBorderPixels) edgeDir += flatRight;
            if (mp.y <= edgeBorderPixels) edgeDir += -flatForward;
            if (mp.y >= Screen.height - edgeBorderPixels) edgeDir += flatForward;

            if (edgeDir.sqrMagnitude > 0.0001f)
            {
                edgeDir.Normalize();
                panVel += edgeDir * edgeScrollSpeed;
            }
        }

        // Apply pan velocity
        pos += panVel * Time.deltaTime;

        // Mouse wheel zoom (smooth)
        float scroll = Input.GetAxis("Mouse ScrollWheel");
        if (Mathf.Abs(scroll) > 0.00001f)
        {
            targetY += scroll * zoomSensitivity;
            targetY = Mathf.Clamp(targetY, minY, maxY);
        }

        // Smooth zoom
        pos.y = Mathf.Lerp(pos.y, targetY, Time.deltaTime * 10f);

        // Optional rotate keys
        if (enableQE)
        {
            if (Input.GetKey(KeyCode.Q))
                transform.Rotate(Vector3.up, -rotateKeySpeed * Time.deltaTime, Space.World);
            if (Input.GetKey(KeyCode.E))
                transform.Rotate(Vector3.up, rotateKeySpeed * Time.deltaTime, Space.World);
        }

        // Optional bounds clamp
        if (clampToBounds)
        {
            pos.x = Mathf.Clamp(pos.x, minX, maxX);
            pos.z = Mathf.Clamp(pos.z, minZ, maxZ);
        }

        transform.position = pos;

        // Dynamic tilt based on zoom
        float tiltAngle = Mathf.Lerp(30f, 60f, (targetY - minY) / (maxY - minY));
        transform.rotation = Quaternion.Euler(tiltAngle, transform.eulerAngles.y, 0f);
    }
}

==============================
FILE: SciFiMapBootstrap.cs
==============================

using UnityEngine;

public class SciFiMapBootstrap : MonoBehaviour
{
    public int teamCount = 6;
    public Vector3 center = Vector3.zero;
    public float hqRadius = 18f;

    [Header("Roads")]
    public float roadWidth = 2.0f;
    public float roadThickness = 0.05f;

    [Header("Territory Discs")]
    public float territoryRadius = 20f;
    public float territoryThickness = 0.02f;
    [Range(0f, 6f)] public float territoryEmission = 1.2f;

    [Header("Center Beacon")]
    public float beaconHeight = 10f;
    [Range(0f, 6f)] public float beaconEmission = 2.5f;

    static readonly int ColorID = Shader.PropertyToID("_Color");
    static readonly int EmissionID = Shader.PropertyToID("_EmissionColor");

    void Start()
    {
        CreateBeacon();
        CreateNeonRoads();
        CreateTerritories();
    }

    void CreateBeacon()
    {
        var beacon = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
        beacon.name = "CenterBeacon";
        beacon.transform.position = center + new Vector3(0f, beaconHeight * 0.5f, 0f);
        beacon.transform.localScale = new Vector3(2f, beaconHeight * 0.5f, 2f);

        Destroy(beacon.GetComponent<Collider>());

        var r = beacon.GetComponent<Renderer>();
        if (r != null)
        {
            var block = new MaterialPropertyBlock();
            Color c = new Color(0.2f, 0.9f, 1f);
            block.SetColor(ColorID, c);
            block.SetColor(EmissionID, c * beaconEmission);
            r.SetPropertyBlock(block);
        }
    }

    void CreateNeonRoads()
    {
        for (int teamID = 0; teamID < teamCount; teamID++)
        {
            float angle = (360f / teamCount) * teamID;
            Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;

            Vector3 a = center;
            Vector3 b = center + dir * hqRadius;
            Vector3 mid = (a + b) * 0.5f;
            float len = Vector3.Distance(a, b);

            var road = GameObject.CreatePrimitive(PrimitiveType.Cube);
            road.name = $"NeonRoad_Team{teamID}";
            road.transform.position = mid + new Vector3(0f, roadThickness * 0.5f, 0f);
            road.transform.localScale = new Vector3(roadWidth, roadThickness, len);
            road.transform.rotation = Quaternion.LookRotation((b - a).normalized, Vector3.up);

            Destroy(road.GetComponent<Collider>());

            if (TeamColorManager.Instance == null) continue;

            Color c = TeamColorManager.Instance.GetTeamColor(teamID);
            var r = road.GetComponent<Renderer>();
            if (r != null)
            {
                var block = new MaterialPropertyBlock();
                block.SetColor(ColorID, Color.Lerp(c, Color.black, 0.55f));
                block.SetColor(EmissionID, c * 0.9f);
                r.SetPropertyBlock(block);
            }
        }
    }

    void CreateTerritories()
    {
        if (TeamColorManager.Instance == null) return;

        for (int teamID = 0; teamID < teamCount; teamID++)
        {
            float angle = (360f / teamCount) * teamID;
            Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;
            Vector3 pos = center + dir * (hqRadius * 0.85f);

            var disc = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
            disc.name = $"HoloTerritory_Team{teamID}";
            disc.transform.position = pos + new Vector3(0f, territoryThickness * 0.5f, 0f);
            disc.transform.localScale = new Vector3(territoryRadius, territoryThickness, territoryRadius);

            Destroy(disc.GetComponent<Collider>());

            Color c = TeamColorManager.Instance.GetTeamColor(teamID);
            var r = disc.GetComponent<Renderer>();
            if (r != null)
            {
                var block = new MaterialPropertyBlock();
                block.SetColor(ColorID, Color.Lerp(c, Color.white, 0.35f));
                block.SetColor(EmissionID, c * territoryEmission);
                r.SetPropertyBlock(block);
            }
        }
    }
}


==============================
FILE: SixTeamBootstrap.cs
==============================

using UnityEngine;

public class SixTeamBootstrap : MonoBehaviour
{
    [Header("Teams")]
    public int teamCount = 6;
    public int playerTeamID = 0;

    [Header("Prefabs")]
    public GameObject hqPrefab;
    public GameObject civilianPrefab;

    [Header("Spawn Layout")]
    public float spawnRadius = 40f;
    public float civilianOffset = 3.0f;

    [Header("Starting Civilians Per Team")]
    public int startingGatherersPerTeam = 1;
    public int startingBuildersPerTeam = 1;

    void Start()
    {
        SpawnTeams();
    }

    void SpawnTeams()
    {
        Vector3 center = Vector3.zero;

        for (int team = 0; team < teamCount; team++)
        {
            float a = (team / (float)teamCount) * Mathf.PI * 2f;
            Vector3 pos = center + new Vector3(Mathf.Cos(a), 0f, Mathf.Sin(a)) * spawnRadius;

            Quaternion rot = Quaternion.LookRotation((center - pos).normalized, Vector3.up);

            GameObject hq = Instantiate(hqPrefab, pos, rot);
            ApplyTeamToObject(hq, team);

            // Spawn civilians near HQ
            Vector3 right = hq.transform.right;
            Vector3 forward = hq.transform.forward;

            int index = 0;

            for (int i = 0; i < startingGatherersPerTeam; i++)
            {
                Vector3 cpos = pos + right * (civilianOffset + index * 1.25f) + forward * 1.5f;
                SpawnCivilian(team, CivilianRole.Gatherer, cpos, rot);
                index++;
            }

            for (int i = 0; i < startingBuildersPerTeam; i++)
            {
                Vector3 cpos = pos - right * (civilianOffset + index * 1.25f) + forward * 1.5f;
                SpawnCivilian(team, CivilianRole.Builder, cpos, rot);
                index++;
            }
        }
    }

    void SpawnCivilian(int teamID, CivilianRole role, Vector3 pos, Quaternion rot)
    {
        if (civilianPrefab == null) return;

        GameObject c = Instantiate(civilianPrefab, pos, rot);
        ApplyTeamToObject(c, teamID);

        Civilian civ = c.GetComponent<Civilian>();
        if (civ != null)
        {
            civ.teamID = teamID;
            civ.SetRole(role);
        }

        TeamVisual tv = c.GetComponent<TeamVisual>();
        if (tv != null)
        {
            tv.teamID = teamID;
            tv.kind = VisualKind.Unit;
            tv.Apply();
        }
    }

    void ApplyTeamToObject(GameObject obj, int teamID)
    {
        if (obj == null) return;

        // Apply to root AND children (important: HQ storage/dropoff often live on child objects)
        ApplyTeamToAllInChildren<Building>(obj, teamID, (c, t) => c.teamID = t);
        ApplyTeamToAllInChildren<Headquarters>(obj, teamID, (c, t) => c.teamID = t);
        ApplyTeamToAllInChildren<ResourceDropoff>(obj, teamID, (c, t) => c.teamID = t);
        ApplyTeamToAllInChildren<ResourceStorageProvider>(obj, teamID, (c, t) => c.teamID = t);

        // FIX: also set ResourceStorageContainer teamID (this was missing)
        ApplyTeamToAllInChildren<ResourceStorageContainer>(obj, teamID, (c, t) => c.teamID = t);

        ApplyTeamToAllInChildren<Civilian>(obj, teamID, (c, t) => c.teamID = t);
        ApplyTeamToAllInChildren<Unit>(obj, teamID, (c, t) => c.teamID = t);

        // Team visuals (root + children)
        var buildingOnRoot = obj.GetComponent<Building>();
        ApplyTeamToAllInChildren<TeamVisual>(obj, teamID, (tv, t) =>
        {
            tv.teamID = t;
            // If this specific object has a Building component, treat it as building; otherwise unit
            tv.kind = (tv.GetComponent<Building>() != null || buildingOnRoot != null) ? VisualKind.Building : VisualKind.Unit;
            tv.Apply();
        });
    }

    void ApplyTeamToAllInChildren<T>(GameObject obj, int teamID, System.Action<T, int> apply) where T : Component
    {
        if (obj == null) return;

        T[] comps = obj.GetComponentsInChildren<T>(true);
        for (int i = 0; i < comps.Length; i++)
        {
            if (comps[i] == null) continue;
            apply(comps[i], teamID);
        }
    }
}


==============================
FILE: Spawner.cs
==============================

using UnityEngine;

public class Spawner : MonoBehaviour
{
    public GameObject unitPrefab;
    public int teamID;
    public int count = 20;
    public Vector3 spawnArea;

    void Start()
    {
        for (int i = 0; i < count; i++)
        {
            Vector3 pos = transform.position +
                new Vector3(
                    Random.Range(-spawnArea.x, spawnArea.x),
                    0.5f,
                    Random.Range(-spawnArea.z, spawnArea.z)
                );

            GameObject u = Instantiate(unitPrefab, pos, Quaternion.identity);
            u.GetComponent<Unit>().teamID = teamID;
            TeamColorManager.Instance.ApplyTeamColor(u, teamID);
        }
    }
}


==============================
FILE: Dependencies.cs
==============================

// ============================================================================
// Cube Wars — Global Dependency Map (Alphabetical + Category-Based)
// This file is documentation-only. It compiles, but contains no runtime logic.
// ============================================================================

using UnityEngine;

public class dependencies : MonoBehaviour
{
    /*
    ========================================================================
    = MASTER INDEX (A–Z) — Script Name + Purpose + Category
    ========================================================================

    AIBuildingPriority.cs — AI building priority weights (AI System)
    AIBuilder.cs — AI building placement logic (AI System)
    AIDifficulty.cs — Difficulty presets for AI behavior (AI System)
    AIEconomy.cs — AI economic management (AI System)
    AIManager.cs — Global AI coordinator (AI System)
    AIMilitary.cs — AI combat and army logic (AI System)
    AIPersonality.cs — Defines AI personality traits (AI System)
    AIPlayer.cs — Root AI brain per team (AI System)
    AIRebuildManager.cs — AI rebuilding destroyed structures (AI System)
    AIRepairManager.cs — AI repairing damaged buildings (AI System)
    AIResourceManager.cs — AI resource flow management (AI System)
    AIThreatDetector.cs — AI threat scanning and alerts (AI System)
    AlertManager.cs — Global alert/event notifications (Core)
    Attackable.cs — Base attackable component (Combat)
    AutoDestroyFX.cs — Auto-destroy particle effects (Combat)
    Barracks.cs — Produces infantry units (Buildings)
    BuildCatalog.cs — Catalog of buildable items (Buildings)
    BuildCellReservation.cs — Blocks grid cells for placement (Buildings)
    BuildGridCell.cs — Represents a buildable grid tile (Buildings)
    BuildGridManager.cs — Generates and manages build grid (Buildings)
    BuildItemDefinition.cs — Metadata for buildings (Buildings)
    BuildItemInstance.cs — Runtime instance of a building type (Buildings)
    BuildMenuUI.cs — UI for selecting buildings (UI)
    BuildPlacementManager.cs — Handles all building placement (Buildings)
    BuildTimeSettings.cs — Global build time modifiers (Buildings)
    Building.cs — Base class for all buildings (Buildings)
    CharacterStats.cs — Health, speed, combat stats (Core)
    Civilian.cs — Worker unit with jobs and skills (Civilians)
    CivilianRole.cs — Enum of civilian job roles (Civilians)
    CivilianSpawner.cs — Spawns civilians (Civilians)
    CombatManager.cs — Global combat coordinator (Combat)
    CombatStance.cs — Unit stance definitions (Combat)
    ConstructionManager.cs — UI for construction progress (UI)
    ConstructionSite.cs — In-progress building logic (Buildings)
    CraftingSystem.cs — Building crafting/refinement logic (Buildings)
    DefenseTurret.cs — Automated turret logic (Buildings)
    DiplomacyManager.cs — Handles alliances and hostility (Combat)
    EventManager.cs — Global event dispatcher (Core)
    Farm.cs — Produces food resources (Buildings)
    FindTeamDuplicates.cs — Debug tool for detecting duplicate teams (Debug)
    GameBootstrap.cs — High-level scene initialization (Core)
    GameManager.cs — Global game state manager (Core)
    Headquarters.cs — HQ building logic (Buildings)
    HQSpawner.cs — Documentation placeholder (Documents)
    IAttackable.cs — Interface for attackable objects (Combat)
    ICommandable.cs — Interface for commandable units (Combat)
    IHasHealth.cs — Interface for health-bearing objects (Combat)
    ITargetable.cs — Interface for targetable objects (Combat)
    IMGUIInputBlocker.cs — Blocks IMGUI input (UI)
    JobManager.cs — Manages civilian jobs and assignments (Civilians)
    MainMenuUI.cs — Main menu logic (UI)
    MapVisualsBootstrap.cs — Initializes map visuals (UI)
    Minimap.cs — Minimap rendering and tracking (UI)
    NeonRing.cs — Visual effect for selection rings (UI)
    ParentRenamer.cs — Utility for renaming parents (Core)
    Projectile.cs — Projectile behavior (Combat)
    ProjectilePool.cs — Pooling for projectiles (Combat)
    ResourceCapacityEntry.cs — Defines storage capacity (Buildings)
    ResourceCost.cs — Defines resource costs (Buildings)
    ResourceDropoff.cs — Dropoff point for resources (Buildings)
    ResourceNode.cs — Resource node logic (Buildings)
    ResourceRegistry.cs — Registry of resource types (Buildings)
    ResourceSpawner.cs — Spawns resource nodes (Buildings)
    ResourceStorageContainer.cs — Per-building storage (Buildings)
    ResourceStorageProvider.cs — Provides storage to workers (Buildings)
    ResourceType.cs — Enum of resource types (Core)
    ResourceVisualBuilder.cs — Builds resource visuals (Buildings)
    RTSCamera.cs — RTS camera controller (Core)
    SaveLoadManager.cs — Save/load system (Core)
    SciFiMapBootstrap.cs — Map initialization (Core)
    SciFiTeamStyler.cs — Advanced team styling system (Core)
    Selectable.cs — Selectable object logic (Core)
    SelfRenamer.cs — Auto-renames objects (Core)
    SixTeamBootstrap.cs — Legacy bootstrap for 6 teams (Core)
    SkirmishConfig.cs — Skirmish mode configuration (Combat)
    Spawner.cs — Generic object spawner (Core)
    TaskBoardUI.cs — UI for job/task management (UI)
    Team.cs — Represents a team/faction (Core)
    TeamAIBuild.cs — Legacy/simple AI builder (AI System)
    TeamBootstrap.cs — UI-based team bootstrap (UI)
    TeamColorManager.cs — Team color lookup (Core)
    TeamColorUtils.cs — Utility for team color operations (Core)
    TeamInventory.cs — Per-team inventory (Core)
    TeamResources.cs — Resource façade for teams (Core)
    TeamStorageManager.cs — Storage backend for teams (Core)
    TeamVisual.cs — Applies team visuals (Core)
    TeamWatchdog.cs — Debug tool for detecting team deletion (Debug)
    Turret.cs — Turret base logic (Combat)
    TurretProjectile.cs — Turret projectile logic (Combat)
    TurretProjectilePool.cs — Pooling for turret projectiles (Combat)
    Unit.cs — Base unit logic (Combat)
    UnitCombatController.cs — Unit combat behavior (Combat)
    UnitCommandController.cs — Unit command handling (Combat)
    UnitInspectorUI.cs — UI for unit inspection (UI)
    UnitManager.cs — Global unit manager (Combat)
    UnitProductionDefinition.cs — Defines unit production data (Combat)
    UnitProductionQueue.cs — Production queue for units (Combat)
    VehicleFactory.cs — Produces vehicles (Buildings)
    WeaponComponent.cs — Weapon firing logic (Combat)
    WeaponsFactory.cs — Produces weapons (Buildings)
    WinConditionManager.cs — Win/loss evaluation (Core)
    WorldHealthBar.cs — World-space health bar UI (UI)


    ========================================================================
    = CATEGORY-BASED DEPENDENCY SECTIONS
    ========================================================================

    ------------------------------------------------------------------------
    AI SYSTEM
    ------------------------------------------------------------------------
    AIBuilder.cs
    AIBuildingPriority.cs
    AIDifficulty.cs
    AIEconomy.cs
    AIManager.cs
    AIMilitary.cs
    AIPersonality.cs
    AIPlayer.cs
    AIRebuildManager.cs
    AIRepairManager.cs
    AIResourceManager.cs
    AIThreatDetector.cs
    MultiTeamAIDirector.cs
    TeamAIBuild.cs

    ------------------------------------------------------------------------
    BUILDING SYSTEM
    ------------------------------------------------------------------------
    Barracks.cs
    BuildCatalog.cs
    BuildCellReservation.cs
    BuildGridCell.cs
    BuildGridManager.cs
    BuildItemDefinition.cs
    BuildItemInstance.cs
    BuildPlacementManager.cs
    BuildTimeSettings.cs
    Building.cs
    ConstructionSite.cs
    CraftingSystem.cs
    DefenseTurret.cs
    Farm.cs
    Headquarters.cs
    ResourceCapacityEntry.cs
    ResourceCost.cs
    ResourceDropoff.cs
    ResourceNode.cs
    ResourceRegistry.cs
    ResourceSpawner.cs
    ResourceStorageContainer.cs
    ResourceStorageProvider.cs
    ResourceVisualBuilder.cs
    VehicleFactory.cs
    WeaponsFactory.cs

    ------------------------------------------------------------------------
    CIVILIAN SYSTEM
    ------------------------------------------------------------------------
    Civilian.cs
    CivilianRole.cs
    CivilianSpawner.cs
    JobManager.cs
    SkillType.cs

    ------------------------------------------------------------------------
    COMBAT SYSTEM
    ------------------------------------------------------------------------
    Attackable.cs
    AutoDestroyFX.cs
    CombatManager.cs
    CombatStance.cs
    DiplomacyManager.cs
    IAttackable.cs
    ICommandable.cs
    IHasHealth.cs
    ITargetable.cs
    Projectile.cs
    ProjectilePool.cs
    SkirmishConfig.cs
    Turret.cs
    TurretProjectile.cs
    TurretProjectilePool.cs
    Unit.cs
    UnitCombatController.cs
    UnitCommandController.cs
    UnitManager.cs
    UnitProductionDefinition.cs
    UnitProductionQueue.cs
    WeaponComponent.cs

    ------------------------------------------------------------------------
    CORE SYSTEM
    ------------------------------------------------------------------------
    AlertManager.cs
    CharacterStats.cs
    EventManager.cs
    GameBootstrap.cs
    GameManager.cs
    ParentRenamer.cs
    ResourceType.cs
    RTSCamera.cs
    SaveLoadManager.cs
    SciFiMapBootstrap.cs
    SciFiTeamStyler.cs
    Selectable.cs
    SelfRenamer.cs
    SixTeamBootstrap.cs
    Spawner.cs
    Team.cs
    TeamColorManager.cs
    TeamColorUtils.cs
    TeamInventory.cs
    TeamResources.cs
    TeamStorageManager.cs
    TeamVisual.cs
    WinConditionManager.cs

    ------------------------------------------------------------------------
    DEBUG
    ------------------------------------------------------------------------
    FindTeamDuplicates.cs
    TeamWatchdog.cs

    ------------------------------------------------------------------------
    DOCUMENTS (Design-Only)
    ------------------------------------------------------------------------
    CombatSystem.cs
    HQSpawner.cs

    ------------------------------------------------------------------------
    UI SYSTEM
    ------------------------------------------------------------------------
    BuildMenuUI.cs
    ConstructionManager.cs
    EconomyUI.cs
    IMGUIInputBlocker.cs
    MainMenuUI.cs
    MapVisualsBootstrap.cs
    Minimap.cs
    NeonRing.cs
    SelectionManager.cs
    SelectionRing.cs
    TaskBoardUI.cs
    TeamBootstrap.cs
    UnitInspectorUI.cs
    WorldHealthBar.cs

    */
}

==============================
FILE: AIDifficulty.cs
==============================

public enum AIDifficulty
{
    Easy,
    Normal,
    Hard
}


==============================
FILE: AIPersonality.cs
==============================

public enum AIPersonality
{
    Aggressive,
    Balanced,
    Defensive
}


==============================
FILE: Team.cs
==============================

using UnityEngine;

/// <summary>
/// Defines whether a team is controlled by the player or AI.
/// 
/// IMPORTANT:
/// - Keeping this enum in the SAME file as Team ensures Unity never loses it.
/// - Avoid placing this enum in other folders or duplicate files.
/// </summary>
public enum TeamType
{
    Player,
    AI
}

/// <summary>
/// Represents a single team in Cube Wars.
///
/// DEPENDENCIES:
/// - TeamResources:
///     Tracks resources for this team.
/// - TeamColorManager:
///     Applies team colors to units/buildings.
/// - TeamInventory:
///     Stores items and crafting materials.
/// - TeamStorageManager:
///     Manages storage buildings and capacity.
/// - TeamBootstrap:
///     Spawns HQs, workers, and AI scripts.
/// - GameManager:
///     Detects and tracks all teams.
/// - Building / Unit:
///     Use teamID for ownership and combat targeting.
///
/// RESPONSIBILITIES:
/// - Identify team (ID + type)
/// - Provide root containers for HQ, units, buildings
/// - Auto-detect team systems
/// - Store team color
///
/// IMPORTANT:
/// - This script NEVER deletes teams.
/// - This script NEVER spawns anything.
/// - Pure data + references.
/// </summary>
public class Team : MonoBehaviour
{
    // ---------------------------------------------------------
    // TEAM IDENTITY
    // ---------------------------------------------------------
    [Header("Team Identity")]
    [Tooltip("Unique ID for this team (1 = Player, 2+ = AI teams).")]
    public int teamID = 1;

    [Tooltip("Whether this team is controlled by the player or AI.")]
    public TeamType teamType = TeamType.Player;

    [Tooltip("Color used for units, buildings, UI, minimap icons, etc.")]
    public Color teamColor = Color.white;


    // ---------------------------------------------------------
    // TEAM ROOT STRUCTURE
    // ---------------------------------------------------------
    [Header("Team Structure (Auto-Detected)")]
    [Tooltip("Root object containing this team's HQ building.")]
    public Transform hqRoot;

    [Tooltip("Root object containing all units belonging to this team.")]
    public Transform unitsRoot;

    [Tooltip("Root object containing all buildings belonging to this team.")]
    public Transform buildingsRoot;


    // ---------------------------------------------------------
    // TEAM SYSTEMS
    // ---------------------------------------------------------
    [Header("Team Systems (Auto-Detected)")]
    [Tooltip("Tracks resources (wood, stone, food, gold, etc.) for this team.")]
    public TeamResources teamResources;

    [Tooltip("Applies team colors to units, buildings, UI, minimap, etc.")]
    public TeamColorManager teamColorManager;

    [Tooltip("Handles inventory items, crafting materials, etc.")]
    public TeamInventory teamInventory;

    [Tooltip("Manages storage buildings and capacity for this team.")]
    public TeamStorageManager teamStorageManager;


    // ---------------------------------------------------------
    // INITIALIZATION
    // ---------------------------------------------------------
    void Awake()
    {
        // Auto-detect child roots if not assigned
        if (hqRoot == null) hqRoot = transform.Find("HQ");
        if (unitsRoot == null) unitsRoot = transform.Find("Units");
        if (buildingsRoot == null) buildingsRoot = transform.Find("Buildings");

        // Auto-detect team systems if they exist on this object
        if (teamResources == null) teamResources = GetComponent<TeamResources>();
        if (teamColorManager == null) teamColorManager = GetComponent<TeamColorManager>();
        if (teamInventory == null) teamInventory = GetComponent<TeamInventory>();
        if (teamStorageManager == null) teamStorageManager = GetComponent<TeamStorageManager>();
    }
}

==============================
FILE: TeamInventory.cs
==============================

// =============================================================
// TeamInventory.cs
//
// PURPOSE:
// - Stores per-team tool counts (e.g., equipment, crafting tools).
//
// DEPENDENCIES:
// - ToolItem:
//      * Represents a tool type.
// - Team.cs:
//      * teamID determines which inventory bucket to use.
//
// NOTES FOR FUTURE MAINTENANCE:
// - This script uses a global singleton pattern.
//   DO NOT attach this script to multiple objects.
// - Consider replacing the singleton with a per-team component.
// - Inventory is stored in dictionaries for fast lookup.
//
// IMPORTANT:
// - This script does NOT delete teams.
// =============================================================

using System.Collections.Generic;
using UnityEngine;

public class TeamInventory : MonoBehaviour
{
    public static TeamInventory Instance;

    [Header("Teams")]
    public int teamCount = 6;

    private Dictionary<int, Dictionary<ToolItem, int>> tools =
        new Dictionary<int, Dictionary<ToolItem, int>>();

    void Awake()
    {
        Instance = this;

        for (int t = 0; t < teamCount; t++)
            tools[t] = new Dictionary<ToolItem, int>();
    }

    public int GetToolCount(int teamID, ToolItem item)
    {
        if (item == null) return 0;
        if (!tools.TryGetValue(teamID, out var dict)) return 0;
        dict.TryGetValue(item, out int c);
        return c;
    }

    public void AddTool(int teamID, ToolItem item, int amount)
    {
        if (item == null || amount <= 0) return;
        if (!tools.TryGetValue(teamID, out var dict))
        {
            dict = new Dictionary<ToolItem, int>();
            tools[teamID] = dict;
        }

        dict.TryGetValue(item, out int c);
        dict[item] = c + amount;
    }

    public bool RemoveTool(int teamID, ToolItem item, int amount)
    {
        if (item == null || amount <= 0) return false;
        if (!tools.TryGetValue(teamID, out var dict)) return false;
        dict.TryGetValue(item, out int c);
        if (c < amount) return false;
        c -= amount;
        if (c <= 0) dict.Remove(item);
        else dict[item] = c;
        return true;
    }
}

==============================
FILE: BuildCatalog.cs
==============================

// ============================================================================
// BuildCatalog.cs
//
// PURPOSE:
// - Defines the list of all buildable items available in the game.
// - Organizes items into high-level categories for UI and AI.
// - Acts as the source of truth for BuildMenuUI when auto-discovering items.
//
// DEPENDENCIES:
// - BuildItemDefinition:
//      * Each entry in 'items' references a ScriptableObject describing a building.
// - BuildMenuUI:
//      * Reads categoryOrder and items to build the UI.
//      * Uses categoryOrder to sort categories in the UI.
// - AIBuilder / TeamAIBuild:
//      * Uses BuildCatalog to determine what buildings exist.
//      * Uses BuildItemDefinition.category and aiPriority for decision-making.
// - Resources folder (optional):
//      * If BuildMenuUI auto-discovers items, they must be placed in Resources/BuildItems.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new building categories, update categoryOrder to control UI order.
// - If you add new BuildItemDefinition assets, ensure they are included in 'items'
//   OR placed in the Resources path for auto-discovery.
// - If you add AI building logic, ensure category names match AI expectations.
// - If you add localization, displayName should be localized in BuildItemDefinition.
//
// INSPECTOR REQUIREMENTS:
// - categoryOrder: determines the order categories appear in the UI.
// - items: list of all buildable items (optional if using auto-discovery).
// ============================================================================

using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "CubeWars/Build Catalog", fileName = "BuildCatalog")]
public class BuildCatalog : ScriptableObject
{
    public List<string> categoryOrder = new List<string>() { "Economy", "Industry", "Housing", "Defense", "Tech" };
    public List<BuildItemDefinition> items = new List<BuildItemDefinition>();
}

==============================
FILE: BuildItemDefinition.cs
==============================

// ============================================================================
// BuildItemDefinition.cs
//
// PURPOSE:
// - Defines a buildable structure in Cube Wars.
// - Acts as the metadata container for placement, cost, category, AI priority,
//   and prefab reference.
// - Used by UI, AI, construction, and placement systems.
//
// DEPENDENCIES:
// - BuildPlacementManager:
//      * Uses prefab, yOffset, placementOffset, costs.
//      * Uses category + aiPriority for AI building logic.
// - ConstructionSite:
//      * Reads costs and buildTime.
//      * Spawns final building prefab.
// - BuildMenuUI:
//      * Displays displayName, icon, costs, category.
//      * Uses category for grouping.
// - BuildCatalog:
//      * Stores BuildItemDefinition assets.
// - AIBuilder / TeamAIBuild / AIRebuildManager:
//      * Uses category + aiPriority to decide what to build.
// - ResourceCost / ResourceType:
//      * Defines the cost of constructing this building.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new AI building logic, ensure category and aiPriority match AI expectations.
// - If you add building upgrades, consider linking BuildItemDefinition ? UpgradeDefinition.
// - If you add multi-cell buildings, add footprint metadata here.
// - If you add rotation-based placement, add rotation rules here.
// - If you add tech-tree requirements, add prerequisites here.
//
// INSPECTOR REQUIREMENTS:
// - displayName: shown in UI.
// - icon: shown in UI.
// - prefab: MUST contain a Building component or ConstructionSite will fail.
// - costs: resource requirements.
// - buildTime: override for ConstructionSite.
// - category: used by UI + AI.
// - aiPriority: used by AI building logic.
// ============================================================================

using UnityEngine;

[CreateAssetMenu(menuName = "CubeWars/Build Item", fileName = "BuildItem_")]
public class BuildItemDefinition : ScriptableObject
{
    [Header("UI")]
    public string displayName;
    public Sprite icon;

    [Header("Placement")]
    public GameObject prefab;

    [Tooltip("Vertical offset when placing the building.")]
    public float yOffset = 0f;

    [Tooltip("Optional extra placement offset (X/Z). Y is usually driven by yOffset.")]
    public Vector3 placementOffset = Vector3.zero;

    [Header("Cost")]
    public ResourceCost[] costs;

    [Header("Build Time")]
    [Tooltip("Build time in seconds for ConstructionSite. If <= 0, site uses its own baseBuildTime.")]
    public float buildTime = 0f;

    [Header("AI / Category")]
    [Tooltip("High-level category used by AI (e.g. Economy, Industry, Housing, Tech).")]
    public string category = "Economy";

    public AIBuildingPriority aiPriority = AIBuildingPriority.Economy;
}

==============================
FILE: BuildTimeSettings.cs
==============================

// ============================================================================
// BuildTimeSettings.cs
//
// PURPOSE:
// - Defines how long a construction site takes to complete when worked on by builders.
// - Provides tuning values for builder work rate, max builders, and total required work.
// - Acts as a configuration component for ConstructionSite or future building systems.
//
// DEPENDENCIES:
// - ConstructionSite (future integration):
//      * Currently ConstructionSite uses passive build + AddWork().
//      * If you integrate BuildTimeSettings, ConstructionSite should read:
//          buildSeconds
//          maxBuilders
//          workRatePerBuilder
// - JobManager:
//      * Assigns builders to construction sites.
//      * Calls AddWork() based on workRatePerBuilder.
// - Builder AI (Worker / Hauler / Builder roles):
//      * Uses workRatePerBuilder to determine contribution.
// - BuildItemDefinition.buildTime:
//      * Overrides buildSeconds if > 0.
// - AIBuilder / AIRebuildManager:
//      * May use these values to estimate build durations.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add multi-stage construction, each stage may need its own BuildTimeSettings.
// - If you add tech upgrades, modify workRatePerBuilder or maxBuilders dynamically.
// - If you add builder specializations (e.g., Engineer, Laborer), integrate multipliers.
// - If you add weather or morale systems, modify workRatePerBuilder accordingly.
// - If you add construction animations, tie animation speed to workRatePerBuilder.
//
// INSPECTOR REQUIREMENTS:
// - buildSeconds: total work required for 1 builder at workRate=1.
// - maxBuilders: caps simultaneous workers.
// - workRatePerBuilder: contribution per builder per second.
// ============================================================================

using UnityEngine;

public class BuildTimeSettings : MonoBehaviour
{
    [Tooltip("Seconds of work required to complete construction (per 1 builder at workRate=1).")]
    public float buildSeconds = 6f;

    [Tooltip("Maximum number of builders that can work on this site at once.")]
    public int maxBuilders = 2;

    [Tooltip("Work per second contributed by each builder.")]
    public float workRatePerBuilder = 1f;
}

==============================
FILE: ToolItem.cs
==============================

using UnityEngine;

[CreateAssetMenu(menuName = "CubeWars/Tool Item")]
public class ToolItem : ScriptableObject
{
    public string displayName = "Tool";

    [Header("Bonuses")]
    public float moveSpeedBonus = 0f;
    public int carryCapacityBonus = 0;

    [Tooltip("Multiplies HarvestPerTick")]
    public float harvestMultiplier = 1f;

    [Tooltip("Multiplies builder work contribution")]
    public float buildMultiplier = 1f;

    [Tooltip("Multiplies combat damage")]
    public float damageMultiplier = 1f;

    [Header("Craft Cost (spent from TeamResources)")]
    public ResourceCost[] craftCost;
}


==============================
FILE: SkirmishConfig.cs
==============================

[System.Serializable]
public class SkirmishConfig
{
    public int aiCount = 3;
    public AIDifficulty difficulty = AIDifficulty.Normal;
    public bool allowAlliances = false;
}


==============================
FILE: ResourceCapacityEntry.cs
==============================

using System;
using UnityEngine;

[Serializable]
public struct ResourceCapacityEntry
{
    public ResourceType type;
    public int capacity;
}


==============================
FILE: ResourceCost.cs
==============================

using System;
using UnityEngine;

[Serializable]
public struct ResourceCost
{
    public ResourceType type;
    public int amount;
}


==============================
FILE: ResourceType.cs
==============================

public enum ResourceType
{
    Food,
    Gold,

    Wood,
    Stone,
    IronOre,
    Coal,
    Copper,
    Silicon,
    Lithium
}


==============================
FILE: TeamResources.cs
==============================

using UnityEngine;

/// <summary>
/// Global resource façade for Cube Wars.
///
/// DEPENDENCIES:
/// - TeamStorageManager:
///     Actual storage implementation.
/// - ResourceType / ResourceCost:
///     Defines resource kinds and costs.
///
/// RESPONSIBILITIES:
/// - Provide a stable API for resource queries
/// - Forward calls to TeamStorageManager
///
/// IMPORTANT:
/// - Singleton pattern:
///     Only ONE TeamResources should exist.
/// - Does NOT delete teams.
/// </summary>
public class TeamResources : MonoBehaviour
{
    public static TeamResources Instance;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public int GetAvailable(int teamID, ResourceType type)
    {
        if (TeamStorageManager.Instance == null) return 0;
        return TeamStorageManager.Instance.GetAvailable(teamID, type);
    }

    public bool CanAfford(int teamID, ResourceCost[] costs)
    {
        if (TeamStorageManager.Instance == null) return false;
        return TeamStorageManager.Instance.CanAffordAvailable(teamID, costs);
    }

    public bool Spend(int teamID, ResourceCost[] costs)
    {
        if (!CanAfford(teamID, costs))
            return false;

        foreach (var c in costs)
            SpendResource(teamID, c.type, c.amount);

        return true;
    }

    public bool SpendResource(int teamID, ResourceType type, int amount)
    {
        if (TeamStorageManager.Instance == null) return false;
        if (amount <= 0) return true;

        int taken = TeamStorageManager.Instance.Withdraw(teamID, type, amount);
        return taken == amount;
    }

    public int Deposit(int teamID, ResourceType type, int amount)
    {
        if (TeamStorageManager.Instance == null) return 0;
        if (amount <= 0) return 0;

        return TeamStorageManager.Instance.Deposit(teamID, type, amount);
    }

    public int GetFreeCapacity(int teamID, ResourceType type)
    {
        if (TeamStorageManager.Instance == null) return 0;
        return TeamStorageManager.Instance.GetTotalFree(teamID, type);
    }

    public int GetResource(int teamID, ResourceType type)
    {
        if (TeamStorageManager.Instance == null) return 0;
        return TeamStorageManager.Instance.GetTotalStored(teamID, type);
    }
}

==============================
FILE: CharacterStats.cs
==============================

using System;
using UnityEngine;

[Serializable]
public struct SkillProgress
{
    public int level;
    public float xp;
}

public class CharacterStats : MonoBehaviour
{
    [Header("Base Stats")]
    public float baseMoveSpeed = 2.5f;
    public int baseCarryCapacity = 30;
    public int baseHarvestPerTick = 5;
    public float baseBuildMultiplier = 1f;

    [Header("Combat (for military later)")]
    public float baseDamageMultiplier = 1f;

    [Header("Skills")]
    public SkillProgress mining;
    public SkillProgress building;
    public SkillProgress farming;
    public SkillProgress hauling;
    public SkillProgress combat;
    public SkillProgress driving;

    [Header("Equipment")]
    public ToolItem equippedTool;

    public float MoveSpeed
    {
        get
        {
            float v = baseMoveSpeed;
            if (equippedTool != null) v += equippedTool.moveSpeedBonus;
            return Mathf.Max(0.1f, v);
        }
    }

    public int CarryCapacity
    {
        get
        {
            int v = baseCarryCapacity;
            if (equippedTool != null) v += equippedTool.carryCapacityBonus;
            return Mathf.Max(1, v);
        }
    }

    public int HarvestPerTick
    {
        get
        {
            float mult = GetSkillMultiplier(SkillType.Mining);
            float tool = (equippedTool != null) ? equippedTool.harvestMultiplier : 1f;
            float v = baseHarvestPerTick * mult * tool;
            return Mathf.Max(1, Mathf.RoundToInt(v));
        }
    }

    public float BuildWorkMultiplier
    {
        get
        {
            float mult = GetSkillMultiplier(SkillType.Building);
            float tool = (equippedTool != null) ? equippedTool.buildMultiplier : 1f;
            return Mathf.Max(0.05f, baseBuildMultiplier * mult * tool);
        }
    }

    public float DamageMultiplier
    {
        get
        {
            float mult = GetSkillMultiplier(SkillType.Combat);
            float tool = (equippedTool != null) ? equippedTool.damageMultiplier : 1f;
            return Mathf.Max(0.05f, baseDamageMultiplier * mult * tool);
        }
    }

    public float GetSkillMultiplier(SkillType t)
    {
        SkillProgress sp = GetSkill(t);
        // Simple curve: +5% per level
        return 1f + (sp.level * 0.05f);
    }

    public void AddXP(SkillType t, float amount)
    {
        if (amount <= 0f) return;

        SkillProgress sp = GetSkill(t);
        sp.xp += amount;

        // XP curve: 10 * (level+1)^2
        while (sp.xp >= XpToNext(sp.level))
        {
            sp.xp -= XpToNext(sp.level);
            sp.level++;
        }

        SetSkill(t, sp);
    }

    float XpToNext(int level)
    {
        int n = Mathf.Max(0, level) + 1;
        return 10f * n * n;
    }

    public SkillProgress GetSkill(SkillType t)
    {
        switch (t)
        {
            case SkillType.Mining: return mining;
            case SkillType.Building: return building;
            case SkillType.Farming: return farming;
            case SkillType.Hauling: return hauling;
            case SkillType.Combat: return combat;
            case SkillType.Driving: return driving;
            default: return mining;
        }
    }

    public void SetSkill(SkillType t, SkillProgress sp)
    {
        switch (t)
        {
            case SkillType.Mining: mining = sp; break;
            case SkillType.Building: building = sp; break;
            case SkillType.Farming: farming = sp; break;
            case SkillType.Hauling: hauling = sp; break;
            case SkillType.Combat: combat = sp; break;
            case SkillType.Driving: driving = sp; break;
        }
    }
}


==============================
FILE: CivilianRole.cs
==============================

// =============================================================
// CivilianRole.cs
//
// DEPENDENCIES:
// - Civilian: uses this to decide behaviour/state machine
// - JobManager: counts civilians per role
// - TaskBoardUI: displays counts per role, including Idle
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new roles, update Civilian.SetRole(), TaskBoardUI, and any AI/job logic.
// =============================================================

public enum CivilianRole
{
    Gatherer,
    Builder,
    Hauler,
    Idle
}

==============================
FILE: CombatStance.cs
==============================

public enum CombatStance
{
    TakePoint,
    FollowTarget,
    Defend
}


==============================
FILE: SkillType.cs
==============================

public enum SkillType
{
    Mining,
    Building,
    Farming,
    Hauling,
    Combat,
    Driving
}


==============================
FILE: UnitProductionDefinition.cs
==============================

// =============================================================
// UnitProductionDefinition.cs
//
// DEPENDENCIES:
// - Barracks:
//      * Uses unitPrefab, buildTime, costs to enqueue units.
// - UnitProductionQueue:
//      * Uses buildTime and unitName for timing and UI.
// - UnitInspectorUI:
//      * Displays unitName and costs for the player.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new cost types (e.g., population), extend this definition
//   and update Barracks + UI accordingly.
// - Keep unitPrefab consistent with the Unit/UnitCombatController setup.
// =============================================================

using UnityEngine;

[CreateAssetMenu(menuName = "CubeWars/Unit Production Definition")]
public class UnitProductionDefinition : ScriptableObject
{
    public string unitName;
    public GameObject unitPrefab;
    public float buildTime = 5f;
    public ResourceCost[] costs;
}

==============================
FILE: CombatSystem.cs
==============================

// ============================================================================
// CUBE WARS — COMBAT SYSTEM MASTER DOCUMENT
// ============================================================================
//
// This file documents the entire combat architecture of Cube Wars.
// It is NOT executable code. It exists to help developers and AI assistants
// understand how the combat system works, how to extend it, and what each
// GameObject requires in the Inspector.
//
// ============================================================================
// 1. OVERVIEW
// ============================================================================
//
// The combat system in Cube Wars is modular and component-based.
// It is built around four core pillars:
//
//   (A) Attackable              ? Universal health + damage component
//   (B) UnitCombatController    ? Targeting + stance logic
//   (C) WeaponComponent         ? Firing logic + cooldowns
//   (D) Projectile System       ? Projectile + ProjectilePool
//
// Units and Turrets both use the same WeaponComponent and Projectile system.
// The only difference is how they acquire targets.
//
// ============================================================================
// 2. REQUIRED COMPONENTS ON COMBAT UNITS
// ============================================================================
//
// Any GameObject that participates in combat MUST have:
//
//   • Attackable (MonoBehaviour)
//       - Exposes: teamID, IsAlive, TakeDamage(), isCivilian, isBuilding
//       - Allows other units to target and damage this object.
//
//   • UnitCombatController
//       - Handles target acquisition, stance logic, and firing requests.
//       - Requires a WeaponComponent.
//
//   • WeaponComponent
//       - Handles firing cooldowns, muzzle FX, projectile spawning.
//
//   • (Optional) NavMeshAgent
//       - Required for moving units (not needed for turrets).
//
//   • (Optional) Animator
//       - For future animation integration.
//
// Turrets additionally require:
//
//   • A static transform (no movement)
//   • A muzzle Transform for projectile spawn
//
// ============================================================================
// 3. HOW TO CREATE A NEW RANGED UNIT
// ============================================================================
//
// 1. Create a new prefab (e.g., "Archer", "Rifleman", "Mage").
// 2. Add the following components:
//
//      [REQUIRED]
//      - Unit (teamID, health, movement)
//      - Attackable (teamID, health interface)
//      - UnitCombatController (targeting + stance)
//      - WeaponComponent (damage, cooldown, range)
//      - ProjectilePool (must exist in scene ONCE)
//      - Projectile prefab (assigned in WeaponComponent)
//
//      [OPTIONAL]
//      - NavMeshAgent (for movement)
//      - Animator (for future animation hooks)
//
// 3. In WeaponComponent, assign:
//      - projectilePrefab
//      - muzzle Transform
//      - damage, range, fireCooldown
//
// 4. In UnitCombatController, assign:
//      - attackableLayers (layer mask for valid targets)
//
// 5. Add the unit to a UnitProductionDefinition if it should be trainable.
//
// ============================================================================
// 4. HOW TO CREATE A TURRET
// ============================================================================
//
// 1. Create a new prefab (e.g., "ArrowTower", "CannonTurret").
// 2. Add:
//
//      - Turret (sets teamID on components)
//      - Attackable
//      - UnitCombatController
//      - WeaponComponent
//
// 3. Remove NavMeshAgent (turrets do not move).
//
// 4. Assign a muzzle Transform for projectile spawn.
//
// 5. Set:
//      - weapon.range
//      - weapon.damage
//      - weapon.fireCooldown
//
// ============================================================================
// 5. COMPONENT RESPONSIBILITIES
// ============================================================================
//
// ---------------------------------------------------------------------------
// A. Attackable (MonoBehaviour)
// ---------------------------------------------------------------------------
// • Universal health + damage component.
// • Required by units, turrets, buildings, civilians.
// • Exposes:
//      int teamID
//      bool isCivilian
//      bool isBuilding
//      bool IsAlive
//      float CurrentHealth
//      float MaxHealth
//      void TakeDamage(float amount)
//      void Repair(float amount)
//      bool IsDamaged
//
// • Used by:
//      - UnitCombatController (target validation)
//      - WeaponComponent (damage application)
//      - Projectile (impact damage)
//      - AIMilitary (target bias)
//      - UnitInspectorUI (health display)
//      - AlertManager (attack notifications)
//
// • Notes:
//      - If adding armor/shields, modify TakeDamage().
//      - If adding death animations, replace Destroy() with animation events.
//      - If adding pooling, replace Destroy() with pool return.
//
// ---------------------------------------------------------------------------
// B. UnitCombatController
// ---------------------------------------------------------------------------
// • Handles:
//      - Target acquisition
//      - Stance logic (Hold, Guard, Aggressive)
//      - Manual targeting (AIMilitary or player)
//      - Rotating toward target
//      - Calling WeaponComponent.FireAtTarget()
//
// • Does NOT:
//      - Spawn projectiles
//      - Apply damage
//      - Handle cooldowns
//
// ---------------------------------------------------------------------------
// C. WeaponComponent
// ---------------------------------------------------------------------------
// • Handles:
//      - Fire cooldown
//      - Muzzle flash FX
//      - Projectile spawning via ProjectilePool
//
// • Requires:
//      - projectilePrefab
//      - muzzle Transform
//
// ---------------------------------------------------------------------------
// D. Projectile
// ---------------------------------------------------------------------------
// • Homing projectile that tracks a target.
// • Applies damage on impact.
// • Returns to pool via ProjectilePool.
//
// ---------------------------------------------------------------------------
// E. ProjectilePool
// ---------------------------------------------------------------------------
// • One instance in the scene.
// • Pools projectiles by prefab.
// • Prevents GC spikes from Instantiate/Destroy.
//
// ============================================================================
// 6. COMBAT FLOW SUMMARY
// ============================================================================
//
// 1. UnitCombatController searches for a valid target.
// 2. If target is in range:
//      - Unit rotates toward target.
//      - If WeaponComponent.CanFire:
//            WeaponComponent.FireAtTarget(target, teamID)
//
// 3. WeaponComponent:
//      - Spawns projectile via ProjectilePool
//      - Plays muzzle FX
//      - Starts cooldown timer
//
// 4. Projectile:
//      - Homes toward target
//      - On impact:
//            - Calls target.TakeDamage()
//            - Plays impact FX
//            - Returns to pool
//
// ============================================================================
// 7. LAYERS & TAGS REQUIRED
// ============================================================================
//
// • "Attackable" layer recommended for all Attackable objects.
// • UnitCombatController.attackableLayers must include this layer.
// • Civilians and buildings should also be Attackable.
//
// ============================================================================
// 8. COMMON PITFALLS & HOW TO AVOID THEM
// ============================================================================
//
// • Missing ProjectilePool in scene
//      ? Add a GameObject named "ProjectilePool" with the component.
//
// • WeaponComponent.muzzle not assigned
//      ? Projectiles spawn at (0,0,0).
//
// • Attackable missing on units/turrets
//      ? They cannot be targeted or damaged.
//
// • attackableLayers not set
//      ? Units never acquire targets.
//
// • projectilePrefab not assigned
//      ? WeaponComponent silently fails.
//
// ============================================================================
// 9. EXTENDING THE COMBAT SYSTEM
// ============================================================================
//
// You can safely add:
//
// • Melee weapons (no projectile)
// • Beam weapons (continuous damage)
// • AoE explosions
// • Armor/resistance system
// • Weapon upgrades (tech tree)
// • Multiple weapons per unit
//
// The modular design supports all of these.
//
// ============================================================================
// END OF DOCUMENT
// ============================================================================

==============================
FILE: AlertManager.cs
==============================

using UnityEngine;
using System.Collections.Generic;

public class AlertManager : MonoBehaviour
{
    public static AlertManager Instance;

    class Alert
    {
        public string text;
        public float timer;
    }

    List<Alert> alerts = new List<Alert>();

    void Awake()
    {
        Instance = this;
    }

    void OnGUI()
    {
        float y = Screen.height - 200;

        for (int i = alerts.Count - 1; i >= 0; i--)
        {
            var a = alerts[i];
            a.timer -= Time.deltaTime;

            GUI.Label(new Rect(10, y, 400, 20), a.text);
            y -= 22;

            if (a.timer <= 0)
                alerts.RemoveAt(i);
        }
    }

    public void Push(string text, float duration = 3f)
    {
        alerts.Add(new Alert { text = text, timer = duration });
    }
}


==============================
FILE: GameManager.cs
==============================

using UnityEngine;

/// <summary>
/// Central orchestrator for Cube Wars.
/// 
/// Responsibilities:
/// - Detect all teams in the scene
/// - Track player team and AI teams
/// - Provide global access to team data
/// - Handle win/loss conditions (later)
/// - Coordinate high-level game state
///
/// IMPORTANT:
/// This script does NOT spawn, delete, or modify teams.
/// It is intentionally non-destructive.
/// </summary>
public class GameManager : MonoBehaviour
{
    [Header("Teams (Auto-Detected)")]
    [Tooltip("All teams currently active in the scene.")]
    public Team[] allTeams;

    [Tooltip("The player-controlled team.")]
    public Team playerTeam;

    [Tooltip("All AI-controlled teams.")]
    public Team[] aiTeams;

    void Awake()
    {
        Debug.Log("GameManager initialized");

        DetectTeams();
    }

    /// <summary>
    /// Finds all Team components in the scene and categorizes them.
    /// </summary>
    private void DetectTeams()
    {
        allTeams = FindObjectsOfType<Team>();

        // Identify player team
        foreach (var team in allTeams)
        {
            if (team.teamType == TeamType.Player)
            {
                playerTeam = team;
                break;
            }
        }

        // Identify AI teams
        aiTeams = System.Array.FindAll(allTeams, t => t.teamType == TeamType.AI);

        Debug.Log($"Detected {allTeams.Length} teams. Player team: {playerTeam?.teamID}");
    }
}

==============================
FILE: SaveLoadManager.cs
==============================

using UnityEngine;

public class SaveLoadManager : MonoBehaviour
{
    // Placeholder for future save/load system.

    void Awake()
    {
        Debug.Log("SaveLoadManager initialized");
    }
}

==============================
FILE: AIManager.cs
==============================

using UnityEngine;

/// <summary>
/// Placeholder for future AI orchestration.
/// 
/// DEPENDENCIES:
/// - None yet
///
/// RESPONSIBILITIES:
/// - Will eventually coordinate AI players
///
/// IMPORTANT:
/// - Does NOT delete teams
/// </summary>
public class AIManager : MonoBehaviour
{
    void Awake()
    {
        Debug.Log("AIManager initialized");
    }
}

==============================
FILE: CombatManager.cs
==============================

using UnityEngine;

public class CombatManager : MonoBehaviour
{
    // This will eventually coordinate global combat logic,
    // threat detection, and shared combat utilities.

    void Awake()
    {
        Debug.Log("CombatManager initialized");
    }
}

==============================
FILE: DiplomacyManager.cs
==============================

// ============================================================================
// DiplomacyManager.cs
//
// PURPOSE:
// - Central authority for team relationships (war/peace).
// - Determines whether two teams are hostile.
// - Used by combat, AI, and future faction systems.
//
// DEPENDENCIES:
// - UnitCombatController:
//      * Calls AreAtWar(teamA, teamB) to validate targets.
// - Attackable:
//      * teamID is used to determine hostility.
// - AI Systems (AIMilitary, future strategic AI):
//      * Uses AreAtWar() to decide aggression, defense, and priorities.
// - UI Systems (future):
//      * May display diplomatic states.
// - Save/Load System (future):
//      * Must serialize warMatrix.
//
// NOTES FOR FUTURE MAINTENANCE:
// - Currently supports only symmetric war (A ? B). If you add:
//      * Alliances
//      * Neutral factions
//      * One-way hostility (A hates B but B ignores A)
//      * Diplomatic states (Ceasefire, Truce, Alliance)
//   …you will need to expand the data model.
// - warMatrix is not persisted. Add save/load integration if diplomacy
//   should persist between sessions.
// - No event system exists yet. If you add diplomacy UI or AI reactions,
//   consider adding events: OnWarDeclared, OnPeaceMade.
// - Ensure team IDs are consistent across all systems (units, buildings,
//   civilians, turrets).
// ============================================================================

using System.Collections.Generic;
using UnityEngine;

public class DiplomacyManager : MonoBehaviour
{
    public static DiplomacyManager Instance;

    // warMatrix[a] contains all teams that 'a' is at war with.
    private Dictionary<int, HashSet<int>> warMatrix =
        new Dictionary<int, HashSet<int>>();

    void Awake()
    {
        Instance = this;
    }

    /// <summary>
    /// Returns true if teams a and b are hostile.
    /// </summary>
    public bool AreAtWar(int a, int b)
    {
        if (a == b) return false;
        return warMatrix.ContainsKey(a) && warMatrix[a].Contains(b);
    }

    /// <summary>
    /// Declares symmetric war between two teams.
    /// </summary>
    public void DeclareWar(int a, int b)
    {
        Ensure(a);
        Ensure(b);
        warMatrix[a].Add(b);
        warMatrix[b].Add(a);
    }

    /// <summary>
    /// Ends war between two teams.
    /// </summary>
    public void MakePeace(int a, int b)
    {
        if (warMatrix.ContainsKey(a)) warMatrix[a].Remove(b);
        if (warMatrix.ContainsKey(b)) warMatrix[b].Remove(a);
    }

    private void Ensure(int team)
    {
        if (!warMatrix.ContainsKey(team))
            warMatrix[team] = new HashSet<int>();
    }
}

==============================
FILE: TeamColorManager.cs
==============================

// =============================================================
// TeamColorManager.cs
//
// PURPOSE:
// - Provides color lookup for all teams.
// - Applies team colors to units, buildings, UI, and minimap icons.
//
// DEPENDENCIES:
// - Renderer (Unity):
//      * Used to apply color to all materials on an object.
// - Team.cs:
//      * teamID determines which color to use.
// - TeamVisual (optional):
//      * Some objects use TeamVisual to apply colors instead.
//
// NOTES FOR FUTURE MAINTENANCE:
// - Consider switching to MaterialPropertyBlock for performance.
// - Ensure teamColors array matches maximum team count.
// - This script uses a global singleton pattern.
//   DO NOT attach this script to multiple objects.
//
// IMPORTANT:
// - This script does NOT delete teams.
// - If multiple instances exist, only the first survives.
// =============================================================

using UnityEngine;

public class TeamColorManager : MonoBehaviour
{
    public static TeamColorManager Instance;

    [Header("6 Team Colors (index = teamID)")]
    public Color[] teamColors = new Color[6]
    {
        new Color(0.2f, 0.4f, 1f),  // Team 0 - Blue
        new Color(1f, 0.25f, 0.25f),// Team 1 - Red
        new Color(0.2f, 1f, 0.4f),  // Team 2 - Green
        new Color(1f, 0.85f, 0.2f), // Team 3 - Yellow
        new Color(0.75f, 0.35f, 1f),// Team 4 - Purple
        new Color(0.2f, 1f, 1f)     // Team 5 - Cyan
    };

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public Color GetTeamColor(int teamID)
    {
        if (teamColors == null || teamColors.Length == 0) return Color.white;
        if (teamID < 0) teamID = 0;
        if (teamID >= teamColors.Length) teamID = teamID % teamColors.Length;
        return teamColors[teamID];
    }

    public void ApplyTeamColor(GameObject obj, int teamID)
    {
        Color c = GetTeamColor(teamID);

        var renderers = obj.GetComponentsInChildren<Renderer>(true);
        foreach (var r in renderers)
        {
            if (r.material != null)
                r.material.color = c;
        }
    }
}

==============================
FILE: TeamStorageManager.cs
==============================

// =============================================================
// TeamStorageManager.cs
//
// PURPOSE:
// - Central storage backend for all teams.
// - Tracks capacity, stored amounts, reservations, and withdrawals.
//
// DEPENDENCIES:
// - ResourceStorageContainer:
//      * Actual per-building storage.
// - ResourceType / ResourceCost:
//      * Defines resource kinds and costs.
// - TeamResources:
//      * Calls into this for all resource logic.
// - Building / Unit / Civilian:
//      * Excluded from building-only storage queries.
// - ConstructionSite:
//      * Uses reservation APIs.
// - Team.cs:
//      * teamID determines which storage bucket to use.
//
// NOTES FOR FUTURE MAINTENANCE:
// - This script uses a global singleton pattern.
//   DO NOT attach this script to multiple objects.
// - If you add new storage types, update IsBuildingStorage().
// - Withdraw/Deposit must remain consistent with capacity logic.
//
// IMPORTANT:
// - This script does NOT delete teams.
// - It ONLY deletes duplicate TeamStorageManager components,
//   NOT Team GameObjects.
// =============================================================

using System.Collections.Generic;
using UnityEngine;

public class TeamStorageManager : MonoBehaviour
{
    public static TeamStorageManager Instance;

    private readonly Dictionary<int, List<ResourceStorageContainer>> storages =
        new Dictionary<int, List<ResourceStorageContainer>>();

    private readonly Dictionary<int, ResourceStorageContainer> primaryStorage =
        new Dictionary<int, ResourceStorageContainer>();

    private readonly Dictionary<int, Dictionary<ResourceType, int>> siteReserved =
        new Dictionary<int, Dictionary<ResourceType, int>>();

    private readonly Dictionary<int, Dictionary<ResourceType, int>> reservedTotals =
        new Dictionary<int, Dictionary<ResourceType, int>>();

    void Awake()
    {
        Instance = this;
    }

    void EnsureTeam(int teamID)
    {
        if (!storages.ContainsKey(teamID))
            storages[teamID] = new List<ResourceStorageContainer>();

        if (!reservedTotals.ContainsKey(teamID))
        {
            reservedTotals[teamID] = new Dictionary<ResourceType, int>();
            foreach (ResourceType t in System.Enum.GetValues(typeof(ResourceType)))
                reservedTotals[teamID][t] = 0;
        }
    }

    // ------------------- Storage Registration -------------------

    public void Register(ResourceStorageContainer c)
    {
        if (c == null) return;

        RemoveFromAllTeams(c);
        EnsureTeam(c.teamID);

        if (!storages[c.teamID].Contains(c))
            storages[c.teamID].Add(c);

        if (!primaryStorage.ContainsKey(c.teamID) || primaryStorage[c.teamID] == null)
            primaryStorage[c.teamID] = c;
    }

    public void Unregister(ResourceStorageContainer c)
    {
        if (c == null) return;
        RemoveFromAllTeams(c);
    }

    void RemoveFromAllTeams(ResourceStorageContainer c)
    {
        foreach (var kv in storages)
            kv.Value.Remove(c);

        var keys = new List<int>(primaryStorage.Keys);
        for (int i = 0; i < keys.Count; i++)
        {
            int team = keys[i];
            if (primaryStorage.TryGetValue(team, out var p) && p == c)
            {
                if (storages.TryGetValue(team, out var list) && list.Count > 0)
                    primaryStorage[team] = list[0];
                else
                    primaryStorage[team] = null;
            }
        }
    }

    public ResourceStorageContainer GetPrimaryStorage(int teamID)
    {
        EnsureTeam(teamID);

        if (primaryStorage.TryGetValue(teamID, out var p) && p != null)
            return p;

        var list = storages[teamID];
        if (list.Count > 0)
        {
            primaryStorage[teamID] = list[0];
            return list[0];
        }

        return null;
    }

    // ------------------- Totals (All Storages) -------------------

    public int GetTotalStored(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        int sum = 0;
        var list = storages[teamID];

        for (int i = 0; i < list.Count; i++)
            if (list[i] != null) sum += list[i].GetStored(type);

        return sum;
    }

    public int GetTotalCapacity(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        int sum = 0;
        var list = storages[teamID];

        for (int i = 0; i < list.Count; i++)
            if (list[i] != null) sum += list[i].GetCapacity(type);

        return sum;
    }

    public int GetTotalFree(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        int sum = 0;
        var list = storages[teamID];

        for (int i = 0; i < list.Count; i++)
            if (list[i] != null) sum += list[i].GetFree(type);

        return sum;
    }

    // ------------------- Building-only Totals -------------------

    bool IsBuildingStorage(ResourceStorageContainer s)
    {
        if (s == null) return false;

        if (s.GetComponentInParent<Civilian>() != null) return false;
        if (s.GetComponentInParent<Unit>() != null) return false;

        return s.GetComponentInParent<Building>() != null;
    }

    public int GetTotalStoredInBuildings(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        int sum = 0;
        var list = storages[teamID];

        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            if (!IsBuildingStorage(s)) continue;
            sum += s.GetStored(type);
        }

        return sum;
    }

    public int GetTotalCapacityInBuildings(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        int sum = 0;
        var list = storages[teamID];

        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            if (!IsBuildingStorage(s)) continue;
            sum += s.GetCapacity(type);
        }

        return sum;
    }

    public int GetTotalFreeInBuildings(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        int sum = 0;
        var list = storages[teamID];

        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            if (!IsBuildingStorage(s)) continue;
            sum += s.GetFree(type);
        }

        return sum;
    }

    // ------------------- Capacity Management -------------------

    public void AddCapacity(int teamID, ResourceType type, int amount)
    {
        EnsureTeam(teamID);
        if (amount == 0) return;

        var list = storages[teamID];
        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            s.AddCapacity(type, amount);
        }
    }

    public void RemoveCapacity(int teamID, ResourceType type, int amount)
    {
        EnsureTeam(teamID);
        if (amount == 0) return;

        var list = storages[teamID];
        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            s.AddCapacity(type, -amount);
        }
    }

    // ------------------- Reservations -------------------

    public int GetReservedTotal(int teamID, ResourceType type)
    {
        EnsureTeam(teamID);
        return reservedTotals[teamID][type];
    }

    public int GetReservedForSite(int siteKey, ResourceType type)
    {
        if (!siteReserved.TryGetValue(siteKey, out var dict) || dict == null)
            return 0;

        return dict.TryGetValue(type, out var v) ? Mathf.Max(0, v) : 0;
    }

    public int GetAvailable(int teamID, ResourceType type)
    {
        int stored = GetTotalStored(teamID, type);
        int reserved = GetReservedTotal(teamID, type);
        return Mathf.Max(0, stored - reserved);
    }

    public bool CanAffordAvailable(int teamID, ResourceCost[] costs)
    {
        if (costs == null) return true;

        for (int i = 0; i < costs.Length; i++)
        {
            var c = costs[i];
            if (GetAvailable(teamID, c.type) < c.amount)
                return false;
        }
        return true;
    }

    public bool ReserveForSite(int teamID, int siteKey, ResourceCost[] costs)
    {
        if (!CanAffordAvailable(teamID, costs)) return false;

        EnsureTeam(teamID);

        if (!siteReserved.TryGetValue(siteKey, out var dict))
        {
            dict = new Dictionary<ResourceType, int>();
            foreach (ResourceType t in System.Enum.GetValues(typeof(ResourceType)))
                dict[t] = 0;
            siteReserved[siteKey] = dict;
        }

        for (int i = 0; i < costs.Length; i++)
        {
            var c = costs[i];
            dict[c.type] += c.amount;
            reservedTotals[teamID][c.type] += c.amount;
        }

        return true;
    }

    public void ReleaseReservation(int teamID, int siteKey)
    {
        EnsureTeam(teamID);

        if (!siteReserved.TryGetValue(siteKey, out var dict))
            return;

        foreach (var kv in dict)
            reservedTotals[teamID][kv.Key] = Mathf.Max(0, reservedTotals[teamID][kv.Key] - kv.Value);

        siteReserved.Remove(siteKey);
    }

    public int ConsumeReserved(int teamID, int siteKey, ResourceType type, int amount)
    {
        EnsureTeam(teamID);
        if (amount <= 0) return 0;

        if (!siteReserved.TryGetValue(siteKey, out var dict))
            return 0;

        int can = Mathf.Min(amount, dict[type]);
        dict[type] -= can;
        reservedTotals[teamID][type] = Mathf.Max(0, reservedTotals[teamID][type] - can);
        return can;
    }

    // ------------------- Withdraw / Deposit -------------------

    public int Withdraw(int teamID, ResourceType type, int amount)
    {
        EnsureTeam(teamID);
        if (amount <= 0) return 0;

        int remaining = amount;
        int takenTotal = 0;

        var list = storages[teamID];
        for (int i = 0; i < list.Count && remaining > 0; i++)
        {
            var s = list[i];
            if (s == null) continue;

            int took = s.Withdraw(type, remaining);
            takenTotal += took;
            remaining -= took;
        }

        return takenTotal;
    }

    public int Deposit(int teamID, ResourceType type, int amount)
    {
        EnsureTeam(teamID);
        if (amount <= 0) return 0;

        int remaining = amount;
        int acceptedTotal = 0;

        var list = storages[teamID];
        for (int i = 0; i < list.Count && remaining > 0; i++)
        {
            var s = list[i];
            if (s == null) continue;

            int accepted = s.Deposit(type, remaining);
            acceptedTotal += accepted;
            remaining -= accepted;
        }

        return acceptedTotal;
    }

    // ------------------- Queries -------------------

    public ResourceStorageContainer FindNearestStorageWithFree(int teamID, ResourceType type, Vector3 pos)
    {
        EnsureTeam(teamID);

        ResourceStorageContainer best = null;
        float bestD = float.MaxValue;

        var list = storages[teamID];
        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            if (s.GetFree(type) <= 0) continue;

            float d = (s.transform.position - pos).sqrMagnitude;
            if (d < bestD)
            {
                bestD = d;
                best = s;
            }
        }

        return best;
    }

    public ResourceStorageContainer FindNearestStorageWithStored(int teamID, ResourceType type, Vector3 pos)
    {
        EnsureTeam(teamID);

        ResourceStorageContainer best = null;
        float bestD = float.MaxValue;

        var list = storages[teamID];
        for (int i = 0; i < list.Count; i++)
        {
            var s = list[i];
            if (s == null) continue;
            if (s.GetStored(type) <= 0) continue;

            float d = (s.transform.position - pos).sqrMagnitude;
            if (d < bestD)
            {
                bestD = d;
                best = s;
            }
        }

        return best;
    }
}

==============================
FILE: UnitManager.cs
==============================

using UnityEngine;

public class UnitManager : MonoBehaviour
{
    // This will eventually track all units,
    // handle spawning, despawning, and provide lists to AI/UI.

    void Awake()
    {
        Debug.Log("UnitManager initialized");
    }
}

==============================
FILE: WinConditionManager.cs
==============================

using UnityEngine;

public class WinConditionManager : MonoBehaviour
{
    void Update()
    {
        CheckVictory();
    }

    void CheckVictory()
    {
        int aliveTeams = 0;
        int lastTeam = -1;

        foreach (var hq in GameObject.FindObjectsOfType<Headquarters>())
        {
            if (!hq.IsAlive) continue;
            aliveTeams++;
            lastTeam = hq.teamID;
        }

        if (aliveTeams <= 1)
            DeclareWinner(lastTeam);
    }

    void DeclareWinner(int teamID)
    {
        Debug.Log($"TEAM {teamID} WINS!");
        Time.timeScale = 0f;
    }
}


==============================
FILE: Barracks.cs
==============================

// ============================================================================
// Barracks.cs
//
// PURPOSE:
// - Produces units over time using UnitProductionQueue.
// - Acts as a factory for infantry or other unit types.
// - Integrates with UI, AI, and resource systems.
//
// DEPENDENCIES:
// - UnitProductionDefinition:
//      * Defines unit prefab, cost, buildTime.
// - UnitProductionQueue:
//      * Handles timed production.
//      * Barracks subscribes to OnUnitCompleted to spawn units.
// - TeamResources / TeamStorageManager:
//      * Used for CanAfford + Spend before enqueueing.
// - Unit:
//      * Spawned units must have teamID applied.
// - UnitInspectorUI:
//      * Reads:
//          producibleUnits[]
//          CanQueue()
//          QueueUnit()
//          CancelLast()
//          CurrentBuildTime
//          CurrentProgress
//          QueueCount
// - AIEconomy / AIBuilder:
//      * Uses QueueCount, EnqueueUnit(), buildTime proxy.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new unit types, assign them in producibleUnits.
// - If you add tech upgrades, modify buildTime or costs before enqueueing.
// - If you add rally points, spawn units at rally location instead of forward offset.
// - If you add multi-queue buildings, instantiate multiple UnitProductionQueue components.
// - Keep dependency header updated when related systems change.
//
// INSPECTOR REQUIREMENTS:
// - producibleUnits: list of units this building can produce.
// - queue: auto-added if missing.
// ============================================================================

using UnityEngine;

public class Barracks : MonoBehaviour
{
    [Header("Owner")]
    public int teamID;

    [Header("Producible Units")]
    public UnitProductionDefinition[] producibleUnits;

    [Header("Queue System")]
    public UnitProductionQueue queue;

    void Awake()
    {
        if (queue == null)
            queue = gameObject.AddComponent<UnitProductionQueue>();

        queue.OnUnitCompleted += SpawnUnit;
    }

    void SpawnUnit(UnitProductionDefinition def)
    {
        if (def == null || def.unitPrefab == null)
            return;

        GameObject go = Instantiate(
            def.unitPrefab,
            transform.position + transform.forward * 2f,
            Quaternion.identity
        );

        if (go.TryGetComponent<Unit>(out var unit))
            unit.teamID = teamID;
    }

    // ---------- UI / AI API ----------

    public bool CanQueue(UnitProductionDefinition def)
    {
        if (def == null) return false;
        if (TeamResources.Instance == null) return false;

        return TeamResources.Instance.CanAfford(teamID, def.costs);
    }

    public void QueueUnit(UnitProductionDefinition def)
    {
        if (!CanQueue(def))
            return;

        TeamResources.Instance.Spend(teamID, def.costs);
        queue.Enqueue(def);
    }

    public void EnqueueUnit()
    {
        if (producibleUnits == null || producibleUnits.Length == 0)
            return;

        QueueUnit(producibleUnits[0]);
    }

    public float buildTime =>
        (producibleUnits == null || producibleUnits.Length == 0)
            ? 0f
            : producibleUnits[0].buildTime;

    public void CancelLast() => queue.CancelLast();

    public float CurrentBuildTime => queue.CurrentBuildTime;

    public float CurrentProgress => queue.Progress01;

    public int QueueCount => queue != null ? queue.QueueCount : 0;
}

==============================
FILE: Building.cs
==============================

using UnityEngine;

/// <summary>
/// Base class for all buildings in Cube Wars.
///
/// DEPENDENCIES:
/// - ITargetable / IAttackable / IHasHealth:
///     Used by combat, AI targeting, and UI.
/// - ConstructionSite:
///     Spawns final building prefabs that inherit from Building.
/// - BuildPlacementManager:
///     Assigns teamID when placing buildings.
/// - TeamVisual:
///     Applies team colors.
/// - ResourceStorageProvider / ResourceDropoff:
///     Many buildings include these; teamID must be consistent.
///
/// RESPONSIBILITIES:
/// - Store team ownership
/// - Handle health and death
/// - Provide combat targeting info
///
/// IMPORTANT:
/// - Does NOT delete teams.
/// - Only destroys THIS building when health reaches zero.
/// </summary>
public abstract class Building : MonoBehaviour, ITargetable, IHasHealth, IAttackable
{
    [Header("Team")]
    public int teamID;

    [Header("Health")]
    public float maxHealth = 300f;
    public float currentHealth;

    // ITargetable + IAttackable
    public int TeamID => teamID;
    public bool IsAlive => currentHealth > 0;
    public Transform AimPoint => transform;

    // IHasHealth
    public float CurrentHealth => currentHealth;
    public float MaxHealth => maxHealth;

    protected virtual void Start()
    {
        currentHealth = maxHealth;
    }

    public virtual void TakeDamage(float damage)
    {
        if (!IsAlive) return;

        currentHealth -= damage;

        if (currentHealth <= 0f)
        {
            currentHealth = 0f;
            Die();
        }
    }

    protected virtual void Die()
    {
        // Only destroys THIS building, not the team.
        Destroy(gameObject);
    }
}

==============================
FILE: BuildItemInstance.cs
==============================

// ============================================================================
// BuildItemInstance.cs
//
// PURPOSE:
// - Identifies a placed building or construction site by its BuildItemDefinition.
// - Allows systems to query building type without relying on class names.
// - Essential for AI, rebuilding logic, and analytics.
//
// DEPENDENCIES:
// - BuildItemDefinition:
//      * itemId matches the ScriptableObject name (item.name).
// - BuildPlacementManager:
//      * Ensures this component exists on placed buildings.
// - ConstructionSite:
//      * Adds BuildItemInstance to the final building on completion.
// - AIRebuildManager / AIBuilder:
//      * Uses itemId to determine what was built or destroyed.
// - Save/Load System (future):
//      * Should serialize itemId to restore building type.
// - BuildingInspector / UI (future):
//      * Can display building type using itemId.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add building upgrades, itemId should change to the upgraded definition.
// - If you add analytics or statistics, this is the safest identifier to use.
// - If you add multi-building variants (skins, levels), consider adding:
//      * variantId
//      * level
// - If you add a tech tree, itemId can be used to check prerequisites.
//
// INSPECTOR REQUIREMENTS:
// - itemId is auto-assigned by BuildPlacementManager or ConstructionSite.
// ============================================================================

using UnityEngine;

/// <summary>
/// Attached to placed buildings and construction sites so we can count/identify them
/// without relying on specific script/class names like "Turret" or "Stockpile".
/// </summary>
public class BuildItemInstance : MonoBehaviour
{
    [Tooltip("Matches the BuildItemDefinition asset name (item.name).")]
    public string itemId;
}

==============================
FILE: ConstructionSite.cs
==============================

// ============================================================================
// ConstructionSite.cs
//
// PURPOSE:
// - Represents an in-progress building.
// - Tracks resource delivery, build progress, and completion.
// - Spawns the final building prefab when finished.
//
// DEPENDENCIES:
// - BuildItemDefinition:
//      * Provides prefab, costs, buildTime override, category.
// - BuildGridCell:
//      * The grid cell this site occupies; updated on completion.
// - BuildPlacementManager:
//      * Calls Init() when placing a new construction site.
// - TeamStorageManager:
//      * ReserveForSite(teamID, SiteKey, costs)
//      * ReleaseReservation(teamID, SiteKey)
//      * Used for resource reservation and delivery.
// - TeamResources (indirect via TeamStorageManager):
//      * High-level resource façade used elsewhere.
// - JobManager:
//      * CountBuildersOnSite(this) for UI + AI.
//      * Builders call AddWork() and ReceiveDelivery().
// - ResourceStorageProvider / ResourceDropoff / ResourceStorageContainer:
//      * Final building may include these; ApplyTeamToPlacedObject assigns teamID.
// - Building (final prefab):
//      * Must have teamID, IAttackable, IHasHealth, etc.
// - BuildItemInstance:
//      * Added to final building for identification.
// - TeamVisual:
//      * Applies team colors to final building.
// - Team.cs:
//      * teamID determines which team owns the finished building.
//
// NOTES FOR FUTURE MAINTENANCE:
// - This script NEVER deletes Team objects.
//   It only destroys the ConstructionSite GameObject on completion.
// - If you add multi-stage construction, split Complete() into phases.
// - If you add construction animations, trigger them in Update() or Complete().
// - If you add worker-only construction (no passive build), remove passive progress.
// - If you add refunds on cancel, integrate with TeamStorageManager.
// - If you add terrain alignment, adjust placement position in Complete().
// - If you add building upgrades, treat upgrades as new ConstructionSites.
// - If you add save/load, persist buildProgress, delivered, and reservations.
//
// INSPECTOR REQUIREMENTS:
// - baseBuildTime: fallback if BuildItemDefinition.buildTime <= 0.
// - costs: auto-filled from BuildItemDefinition.
// - constructionSitePrefab must contain:
//      * ConstructionSite
//      * BuildItemInstance (optional, added automatically)
//      * TeamVisual (optional)
// ============================================================================

using UnityEngine;
using System.Collections.Generic;

public class ConstructionSite : MonoBehaviour
{
    [Header("Team & Definition")]
    public int teamID;
    public BuildItemDefinition buildItem;   // what we’re building
    public BuildGridCell gridCell;         // cell this site occupies

    [Header("Build Settings")]
    public float baseBuildTime = 10f;      // fallback if item has no override
    public ResourceCost[] costs;

    // State
    public bool InitOK { get; private set; }
    public bool IsComplete => completed;
    public bool MaterialsComplete => HasAllResources();
    public int SiteKey { get; private set; }

    float buildProgress;
    bool completed;

    // delivered[type] = amount delivered to this site
    Dictionary<ResourceType, int> delivered = new Dictionary<ResourceType, int>();

    void Awake()
    {
        SiteKey = GetInstanceID();

        if (costs != null)
        {
            foreach (var c in costs)
                delivered[c.type] = 0;
        }
    }

    void Update()
    {
        if (!InitOK || completed)
            return;

        if (!MaterialsComplete)
            return;

        // Passive build (optional)
        buildProgress += Time.deltaTime;

        float requiredTime = GetBuildTime();
        if (buildProgress >= requiredTime)
            Complete();
    }

    float GetBuildTime()
    {
        if (buildItem != null && buildItem.buildTime > 0f)
            return buildItem.buildTime;
        return Mathf.Max(0.1f, baseBuildTime);
    }

    bool HasAllResources()
    {
        if (costs == null) return true;

        foreach (var c in costs)
        {
            if (!delivered.TryGetValue(c.type, out int have) || have < c.amount)
                return false;
        }
        return true;
    }

    // ---------------- INIT ----------------

    public void Init(BuildGridCell cell, int team, BuildItemDefinition item, bool reserveResources)
    {
        teamID = team;
        gridCell = cell;
        buildItem = item;
        costs = item != null ? item.costs : costs;

        delivered.Clear();
        if (costs != null)
        {
            foreach (var c in costs)
                delivered[c.type] = 0;
        }

        // Reserve resources
        if (reserveResources && TeamStorageManager.Instance != null && costs != null && costs.Length > 0)
        {
            bool ok = TeamStorageManager.Instance.ReserveForSite(teamID, SiteKey, costs);
            if (!ok)
            {
                InitOK = false;
                return;
            }
        }

        InitOK = true;
    }

    // ---------------- WORK / PROGRESS ----------------

    public void AddWork(float workAmount)
    {
        if (!InitOK || completed) return;
        if (!MaterialsComplete) return;

        buildProgress += workAmount;

        float requiredTime = GetBuildTime();
        if (buildProgress >= requiredTime)
            Complete();
    }

    // ---------------- RESOURCE DELIVERY ----------------

    public int GetMissing(ResourceType type)
    {
        if (costs == null) return 0;

        int required = 0;
        for (int i = 0; i < costs.Length; i++)
        {
            if (costs[i].type == type)
            {
                required = costs[i].amount;
                break;
            }
        }

        delivered.TryGetValue(type, out int have);
        return Mathf.Max(0, required - have);
    }

    public int ReceiveDelivery(ResourceType type, int amount)
    {
        if (amount <= 0) return 0;

        int missing = GetMissing(type);
        if (missing <= 0) return 0;

        int accepted = Mathf.Min(missing, amount);

        if (!delivered.ContainsKey(type))
            delivered[type] = 0;

        delivered[type] += accepted;
        return accepted;
    }

    public ResourceCost[] GetRequiredCosts() => costs;

    public int GetDeliveredAmount(ResourceType type) =>
        delivered.TryGetValue(type, out int v) ? v : 0;

    // ---------------- COMPLETE ----------------

    void Complete()
    {
        if (completed) return;
        completed = true;

        if (TeamStorageManager.Instance != null)
            TeamStorageManager.Instance.ReleaseReservation(teamID, SiteKey);

        if (buildItem != null && buildItem.prefab != null)
        {
            Vector3 pos = transform.position;
            Quaternion rot = Quaternion.identity;

            GameObject placed = Instantiate(buildItem.prefab, pos, rot);

            BuildItemInstance bii = placed.GetComponent<BuildItemInstance>();
            if (bii == null) bii = placed.AddComponent<BuildItemInstance>();
            bii.itemId = buildItem.name;

            ApplyTeamToPlacedObject(placed, teamID);

            if (gridCell != null)
            {
                gridCell.isOccupied = true;
                gridCell.placedObject = placed;
            }
        }

        // IMPORTANT:
        // - This destroys ONLY the ConstructionSite, not the Team.
        Destroy(gameObject);
    }

    void ApplyTeamToPlacedObject(GameObject placed, int team)
    {
        if (placed == null) return;

        Building building = placed.GetComponent<Building>();
        if (building != null) building.teamID = team;

        Civilian civ = placed.GetComponent<Civilian>();
        if (civ != null) civ.teamID = team;

        Unit unit = placed.GetComponent<Unit>();
        if (unit != null) unit.teamID = team;

        var sp = placed.GetComponent<ResourceStorageProvider>();
        if (sp != null) sp.teamID = team;

        var drop = placed.GetComponent<ResourceDropoff>();
        if (drop != null) drop.teamID = team;

        var storage = placed.GetComponent<ResourceStorageContainer>();
        if (storage != null) storage.teamID = team;

        TeamVisual tv = placed.GetComponent<TeamVisual>();
        if (tv != null)
        {
            tv.teamID = team;
            tv.kind = (building != null) ? VisualKind.Building : VisualKind.Unit;
            tv.Apply();
        }
    }

    // ---------------- UI HELPERS ----------------

    public float Progress01 =>
        GetBuildTime() > 0f ? Mathf.Clamp01(buildProgress / GetBuildTime()) : 1f;

    public string GetStatusLine()
    {
        if (completed) return "Completed";
        if (!MaterialsComplete) return "Awaiting Materials";
        return "Under Construction";
    }

    public int AssignedBuilderCount =>
        JobManager.Instance != null ? JobManager.Instance.CountBuildersOnSite(this) : 0;
}

==============================
FILE: DefenseTurret.cs
==============================

using UnityEngine;

public class DefenseTurret : Building
{
    [Header("Targeting")]
    public float range = 12f;
    public float scanInterval = 0.2f;
    public LayerMask targetMask; // set to Targetable layer
    public bool canTargetCivilians = true;

    [Header("Fire")]
    public float fireRate = 2f;          // shots per second
    public float damage = 10f;
    public float projectileSpeed = 25f;
    public Transform muzzle;             // assign in prefab
    public TurretProjectile projectilePrefab; // optional (poolable)

    [Header("Aim")]
    public Transform turretHead;         // rotating part (optional)
    public float turnSpeed = 360f;       // degrees per second

    [Header("Simple Attack Flash")]
    public Renderer flashRenderer;       // optional (muzzle mesh or head mesh)
    public float flashSeconds = 0.06f;
    public float flashEmission = 2.0f;

    private float scanTimer;
    private float fireTimer;

    private ITargetable currentTarget;
    private Transform currentTargetTf;

    // NonAlloc buffer (no GC). Increase if you expect lots of targets in range.
    private readonly Collider[] hits = new Collider[64];

    // MaterialPropertyBlock avoids creating per-turret material instances
    private MaterialPropertyBlock mpb;
    private static readonly int EmissionID = Shader.PropertyToID("_EmissionColor");

    protected override void Start()
    {
        base.Start();
        mpb = new MaterialPropertyBlock();
    }

    void Update()
    {
        if (!IsAlive) return;

        scanTimer += Time.deltaTime;
        fireTimer += Time.deltaTime;

        // Reacquire target occasionally (not every frame)
        if (currentTarget == null || !IsValidTarget(currentTarget) || OutOfRange(currentTargetTf))
        {
            if (scanTimer >= scanInterval)
            {
                scanTimer = 0f;
                AcquireTarget();
            }
        }

        if (currentTarget != null && currentTargetTf != null)
        {
            AimAt(currentTargetTf.position);

            // Fire only if aimed roughly at target (optional)
            if (fireTimer >= (1f / Mathf.Max(0.01f, fireRate)))
            {
                fireTimer = 0f;
                Fire();
            }
        }
    }

    void AcquireTarget()
    {
        currentTarget = null;
        currentTargetTf = null;

        int count = Physics.OverlapSphereNonAlloc(transform.position, range, hits, targetMask, QueryTriggerInteraction.Ignore);
        if (count <= 0) return;

        float best = float.MaxValue;
        Collider bestCol = null;

        for (int i = 0; i < count; i++)
        {
            Collider col = hits[i];
            if (col == null) continue;

            // Get ITargetable without allocations
            var targetable = col.GetComponentInParent<ITargetable>();
            if (targetable == null) continue;

            if (!IsValidTarget(targetable)) continue;
            if (!canTargetCivilians && col.GetComponentInParent<Civilian>() != null) continue;

            Transform tf = (targetable as Component)?.transform;
            if (tf == null) continue;

            float d = (tf.position - transform.position).sqrMagnitude;
            if (d < best)
            {
                best = d;
                bestCol = col;
                currentTarget = targetable;
                currentTargetTf = tf;
            }
        }

        // clear buffer refs (optional hygiene)
        for (int i = 0; i < count; i++) hits[i] = null;
    }

    bool IsValidTarget(ITargetable t)
    {
        if (t == null) return false;
        if (!t.IsAlive) return false;
        if (t.TeamID == teamID) return false; // don't shoot own team
        return true;
    }

    bool OutOfRange(Transform tf)
    {
        if (tf == null) return true;
        return (tf.position - transform.position).sqrMagnitude > (range * range);
    }

    void AimAt(Vector3 worldPos)
    {
        if (turretHead == null) return;

        Vector3 dir = worldPos - turretHead.position;
        dir.y = 0f;
        if (dir.sqrMagnitude < 0.001f) return;

        Quaternion targetRot = Quaternion.LookRotation(dir.normalized, Vector3.up);
        turretHead.rotation = Quaternion.RotateTowards(turretHead.rotation, targetRot, turnSpeed * Time.deltaTime);
    }

    void Fire()
    {
        if (currentTargetTf == null) return;

        // Deal damage (direct hit) OR projectile — choose one.
        // If you already have health on units, do direct for max performance:
        var health = currentTargetTf.GetComponentInParent<IHasHealth>();
        if (health != null)
        {
            // Prefer calling a TakeDamage method if you have it on concrete components
            // Example: (health as MonoBehaviour)?.SendMessage("TakeDamage", damage, SendMessageOptions.DontRequireReceiver);

            // If your units/civilians expose TakeDamage(float), call it safely:
            var unit = currentTargetTf.GetComponentInParent<Unit>();
            if (unit != null) unit.TakeDamage(damage);

            var civ = currentTargetTf.GetComponentInParent<Civilian>();
            if (civ != null) civ.TakeDamage(damage);
        }

        // Optional projectile visuals (poolable)
        if (projectilePrefab != null && muzzle != null)
        {
            var proj = TurretProjectilePool.Instance.Spawn(projectilePrefab, muzzle.position, muzzle.rotation);
            proj.Init(teamID, currentTargetTf, damage, projectileSpeed);
        }

        DoFlash();
    }

    void DoFlash()
    {
        if (flashRenderer == null) return;

        // Simple emissive flash via MPB (no new material instances)
        flashRenderer.GetPropertyBlock(mpb);
        mpb.SetColor(EmissionID, Color.white * flashEmission);
        flashRenderer.SetPropertyBlock(mpb);

        CancelInvoke(nameof(ClearFlash));
        Invoke(nameof(ClearFlash), flashSeconds);
    }

    void ClearFlash()
    {
        if (flashRenderer == null) return;
        flashRenderer.GetPropertyBlock(mpb);
        mpb.SetColor(EmissionID, Color.black);
        flashRenderer.SetPropertyBlock(mpb);
    }
}


==============================
FILE: Farm.cs
==============================

using UnityEngine;

public class Farm : Building
{
    [Header("Farm Production")]
    public int level = 1;
    public int maxLevel = 3;

    [Tooltip("Seconds between production ticks.")]
    public float productionInterval = 2f;

    [Header("Per-Level Output (Food per tick)")]
    public int[] foodPerTickByLevel = new int[] { 2, 5, 10 };

    [Header("Upgrade Costs (Gold)")]
    public int[] goldCostByNextLevel = new int[] { 20, 50, 120 };
    // cost to upgrade from level 1->2 uses [0], 2->3 uses [1], etc.

    [Header("Optional: Auto Upgrade")]
    public bool autoUpgrade = false;
    public float autoUpgradeCheckInterval = 2f;

    private float productionTimer;
    private float upgradeTimer;

    protected override void Start()
    {
        base.Start();
        level = Mathf.Clamp(level, 1, maxLevel);
    }

    void Update()
    {
        if (!IsAlive) return;

        ProduceFoodTick();

        if (autoUpgrade)
            AutoUpgradeTick();
    }

    void ProduceFoodTick()
    {
        if (TeamResources.Instance == null) return;

        productionTimer += Time.deltaTime;
        if (productionTimer < productionInterval) return;
        productionTimer = 0f;

        int index = Mathf.Clamp(level - 1, 0, foodPerTickByLevel.Length - 1);
        int foodToProduce = foodPerTickByLevel[index];

        // If no free storage, don't produce (prevents wasting)
        int free = TeamResources.Instance.GetFreeCapacity(teamID, ResourceType.Food);
        if (free <= 0)
            return;

        int accepted = TeamResources.Instance.Deposit(teamID, ResourceType.Food, foodToProduce);

        // Optional: if partially accepted, you can log or just ignore
        if (accepted < foodToProduce)
        {
            // Storage filled up; remaining food is "wasted" (or you can pause production next ticks)
            // Debug.Log($"Team {teamID} Farm could only store {accepted}/{foodToProduce} Food (storage full).");
        }
    }

    void AutoUpgradeTick()
    {
        upgradeTimer += Time.deltaTime;
        if (upgradeTimer < autoUpgradeCheckInterval) return;
        upgradeTimer = 0f;

        TryUpgrade();
    }

    public bool TryUpgrade()
    {
        if (TeamResources.Instance == null) return false;

        if (level >= maxLevel)
            return false;

        int nextLevel = level + 1;
        int costIndex = Mathf.Clamp(level - 1, 0, goldCostByNextLevel.Length - 1);
        int goldCost = goldCostByNextLevel[costIndex];

        // Spend gold to upgrade
        bool paid = TeamResources.Instance.SpendResource(teamID, ResourceType.Gold, goldCost);
        if (!paid) return false;

        level = nextLevel;

        // Simple visual feedback: scale up slightly by level
        float scale = 1f + (level - 1) * 0.15f;
        transform.localScale = new Vector3(scale, scale, scale);

        Debug.Log($"Team {teamID} Farm upgraded to Level {level} (Cost: {goldCost} Gold)");
        return true;
    }
}


==============================
FILE: Headquarters.cs
==============================

using UnityEngine;

public class Headquarters : Building
{
    protected override void Die()
    {
        Debug.Log($"Team {teamID} Headquarters destroyed!");

        // TODO (later): trigger victory / defeat logic here

        base.Die();
    }
}


==============================
FILE: ResourceDropoff.cs
==============================

using System.Collections.Generic;
using UnityEngine;

public class ResourceDropoff : MonoBehaviour
{
    public int teamID;

    [Header("If empty, accepts ANY resource.")]
    public ResourceType[] acceptsOnly;

    private static readonly List<ResourceDropoff> all = new List<ResourceDropoff>();

    void OnEnable()
    {
        if (!all.Contains(this)) all.Add(this);
    }

    void OnDisable()
    {
        all.Remove(this);
    }

    public bool CanAccept(ResourceType t)
    {
        if (acceptsOnly == null || acceptsOnly.Length == 0) return true;
        for (int i = 0; i < acceptsOnly.Length; i++)
            if (acceptsOnly[i] == t) return true;
        return false;
    }

    public int Deposit(ResourceType type, int amount)
    {
        if (!CanAccept(type)) return 0;
        if (TeamResources.Instance == null) return 0;
        return TeamResources.Instance.Deposit(teamID, type, amount);
    }

    public static ResourceDropoff FindNearest(int teamID, ResourceType type, Vector3 from)
    {
        ResourceDropoff best = null;
        float bestD = float.MaxValue;

        for (int i = 0; i < all.Count; i++)
        {
            var d = all[i];
            if (d == null) continue;
            if (d.teamID != teamID) continue;
            if (!d.CanAccept(type)) continue;

            float sq = (d.transform.position - from).sqrMagnitude;
            if (sq < bestD)
            {
                bestD = sq;
                best = d;
            }
        }

        return best;
    }
}


==============================
FILE: ResourceNode.cs
==============================

using UnityEngine;

public class ResourceNode : MonoBehaviour
{
    public ResourceType type;
    public int remaining = 500;

    [HideInInspector]
    public int claimedByTeam = -1;

    public bool IsDepleted => remaining <= 0;

    // Legacy compatibility: some code uses node.amount
    public int amount => remaining;

    public bool IsClaimedByOther(int teamID)
    {
        return claimedByTeam != -1 && claimedByTeam != teamID;
    }

    /// <summary>
    /// Harvests up to 'amount' from this node. Returns how much was actually taken.
    /// </summary>
    public int Harvest(int amount)
    {
        if (amount <= 0 || IsDepleted) return 0;
        int taken = Mathf.Min(remaining, amount);
        remaining -= taken;
        return taken;
    }
}

==============================
FILE: ResourceSpawner.cs
==============================

using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

public class ResourceSpawner : MonoBehaviour
{
    [Serializable]
    public class ResourceSpawnConfig
    {
        public ResourceType type;
        public GameObject prefab;
        [Min(0)] public int count = 10;

        [Header("Node Contents")]
        public Vector2Int amountRange = new Vector2Int(50, 200);
        public Vector2Int valueRange = new Vector2Int(1, 5);

        [Header("Scale by Amount")]
        public bool scaleHeightByAmount = true;
        public int referenceAmount = 200;
        public float minHeightScale = 0.6f;
        public float maxHeightScale = 2.0f;
    }

    // ---------------------------------------------------------
    // DEPENDENCIES:
    // - ResourceNode: must expose `remaining` and `type`
    // - ResourceNode.amount is read-only ? must assign to `remaining`
    // - Prefabs must contain ResourceNode
    // ---------------------------------------------------------

    [Header("Spawn Area (world space)")]
    public Vector3 resourceSpawnCenter = Vector3.zero;
    public Vector2 resourceSpawnSize = new Vector2(80f, 80f);
    public float spawnHeight = 20f;

    [Header("Grounding")]
    public bool snapToGround = true;
    public LayerMask groundMask = ~0;
    public float groundRayLength = 200f;

    [Header("Spawn Rules")]
    public float avoidRadius = 1.2f;
    public int maxAttemptsPerNode = 25;

    [Header("Resource Configs")]
    public List<ResourceSpawnConfig> configs = new List<ResourceSpawnConfig>();

    [Header("Lifecycle")]
    public bool spawnOnStart = true;
    public bool clearPreviousChildren = true;

    void Start()
    {
        if (spawnOnStart)
            SpawnAllResources();
    }

    [ContextMenu("Spawn All Resources")]
    public void SpawnAllResources()
    {
        if (clearPreviousChildren)
            ClearChildren();

        int spawnedTotal = 0;

        foreach (var cfg in configs)
        {
            if (cfg == null || cfg.count <= 0 || cfg.prefab == null) continue;

            for (int i = 0; i < cfg.count; i++)
            {
                if (TrySpawnOne(cfg, out GameObject spawned))
                    spawnedTotal++;
            }
        }

        Debug.Log($"[ResourceSpawner] Spawned total nodes: {spawnedTotal}");
    }

    void ClearChildren()
    {
        for (int i = transform.childCount - 1; i >= 0; i--)
            Destroy(transform.GetChild(i).gameObject);
    }

    bool TrySpawnOne(ResourceSpawnConfig cfg, out GameObject spawned)
    {
        spawned = null;

        for (int attempt = 0; attempt < maxAttemptsPerNode; attempt++)
        {
            Vector3 pos = RandomPointInArea();

            if (snapToGround && !TrySnapToGround(ref pos))
                continue;

            if (avoidRadius > 0f && Physics.CheckSphere(pos, avoidRadius))
                continue;

            spawned = Instantiate(cfg.prefab, pos, Quaternion.identity, transform);

            var node = spawned.GetComponent<ResourceNode>();
            if (node == null)
            {
                Debug.LogWarning("[ResourceSpawner] Spawned prefab has no ResourceNode. Destroying spawned object.");
                Destroy(spawned);
                spawned = null;
                return false;
            }

            // Assign type and random amount
            node.type = cfg.type;

            // FIX: ResourceNode.amount is read-only ? assign to remaining
            node.remaining = UnityEngine.Random.Range(cfg.amountRange.x, cfg.amountRange.y + 1);

            // Optional: assign value if ResourceNode has a compatible field
            TrySetValueOnNode(node, cfg.valueRange);

            // Scale object height based on amount
            if (cfg.scaleHeightByAmount)
                ScaleHeightByAmount(spawned.transform, node.remaining, cfg.referenceAmount, cfg.minHeightScale, cfg.maxHeightScale);

            return true;
        }

        return false;
    }

    Vector3 RandomPointInArea()
    {
        float halfX = resourceSpawnSize.x * 0.5f;
        float halfZ = resourceSpawnSize.y * 0.5f;

        float x = resourceSpawnCenter.x + UnityEngine.Random.Range(-halfX, halfX);
        float z = resourceSpawnCenter.z + UnityEngine.Random.Range(-halfZ, halfZ);

        return new Vector3(x, resourceSpawnCenter.y + spawnHeight, z);
    }

    bool TrySnapToGround(ref Vector3 pos)
    {
        Vector3 origin = pos + Vector3.up * 0.1f;
        if (Physics.Raycast(origin, Vector3.down, out RaycastHit hit, groundRayLength + 0.1f, groundMask, QueryTriggerInteraction.Ignore))
        {
            pos.y = hit.point.y;
            return true;
        }
        return false;
    }

    void ScaleHeightByAmount(Transform t, int amount, int referenceAmount, float minScale, float maxScale)
    {
        if (referenceAmount <= 0) referenceAmount = 1;

        float k = Mathf.Clamp01(amount / (float)referenceAmount);
        float heightScale = Mathf.Lerp(minScale, maxScale, k);

        Vector3 oldScale = t.localScale;
        t.localScale = new Vector3(oldScale.x, oldScale.y * heightScale, oldScale.z);

        float deltaY = oldScale.y * (heightScale - 1f);
        t.position += new Vector3(0f, deltaY * 0.5f, 0f);
    }

    void TrySetValueOnNode(ResourceNode node, Vector2Int valueRange)
    {
        int value = UnityEngine.Random.Range(valueRange.x, valueRange.y + 1);
        string[] candidates = { "valuePerUnit", "value", "nodeValue" };
        Type type = node.GetType();

        foreach (string name in candidates)
        {
            FieldInfo f = type.GetField(name, BindingFlags.Public | BindingFlags.Instance);
            if (f != null && f.FieldType == typeof(int))
            {
                f.SetValue(node, value);
                return;
            }

            PropertyInfo p = type.GetProperty(name, BindingFlags.Public | BindingFlags.Instance);
            if (p != null && p.PropertyType == typeof(int) && p.CanWrite)
            {
                p.SetValue(node, value, null);
                return;
            }
        }
    }
}

==============================
FILE: ResourceStorageContainer.cs
==============================

// =============================================================
// ResourceStorageContainer.cs
//
// PURPOSE:
// - Represents a single storage container for a building or unit.
// - Tracks stored amounts and capacity for each ResourceType.
// - Registers itself with TeamStorageManager for global queries.
//
// DEPENDENCIES:
// - ResourceType:
//      * Enum defining all resource categories.
// - TeamStorageManager:
//      * Registers/unregisters this container.
//      * Aggregates totals, capacity, reservations, and withdrawals.
// - Building / Unit / Civilian:
//      * teamID determines which storage bucket this belongs to.
// - ConstructionSite:
//      * May use this container for temporary storage during building.
//
// NOTES FOR FUTURE MAINTENANCE:
// - This script NEVER deletes teams or GameObjects.
// - This script NEVER enforces singleton behavior.
// - This script NEVER modifies teamID automatically.
// - Capacity and stored values are per-container, not global.
// - If you add new ResourceTypes, they will auto-initialize in Awake().
// - If you add building upgrades, call AddCapacity() accordingly.
//
// ARCHITECTURE:
// - Attached to buildings that provide storage.
// - Registered with TeamStorageManager on enable.
// - Unregistered on disable.
// - Safe to have multiple containers per team.
// =============================================================

using UnityEngine;
using System.Collections.Generic;

public class ResourceStorageContainer : MonoBehaviour
{
    public int teamID;

    Dictionary<ResourceType, int> stored = new Dictionary<ResourceType, int>();
    Dictionary<ResourceType, int> capacity = new Dictionary<ResourceType, int>();

    void Awake()
    {
        foreach (ResourceType t in System.Enum.GetValues(typeof(ResourceType)))
        {
            stored[t] = 0;
            capacity[t] = 0;
        }
    }

    void OnEnable()
    {
        if (TeamStorageManager.Instance != null)
            TeamStorageManager.Instance.Register(this);
    }

    void OnDisable()
    {
        if (TeamStorageManager.Instance != null)
            TeamStorageManager.Instance.Unregister(this);
    }

    public int GetStored(ResourceType type)
    {
        return stored[type];
    }

    public int GetCapacity(ResourceType type)
    {
        return capacity[type];
    }

    public int GetFree(ResourceType type)
    {
        return Mathf.Max(0, capacity[type] - stored[type]);
    }

    public int Deposit(ResourceType type, int amount)
    {
        int free = GetFree(type);
        int accepted = Mathf.Min(free, amount);
        stored[type] += accepted;
        return accepted;
    }

    public int Withdraw(ResourceType type, int amount)
    {
        int taken = Mathf.Min(stored[type], amount);
        stored[type] -= taken;
        return taken;
    }

    public void AddCapacity(ResourceType type, int amount)
    {
        capacity[type] += amount;
    }
}

==============================
FILE: ResourceStorageProvider.cs
==============================

using UnityEngine;

public class ResourceStorageProvider : MonoBehaviour
{
    public int teamID;

    [Header("Capacities provided by this building")]
    public ResourceCapacityEntry[] capacities;

    private bool started;
    private bool registered;

    // ---------------------------------------------------------
    // DEPENDENCIES:
    // - TeamStorageManager: must implement AddCapacity(teamID, type, amount)
    //                       and RemoveCapacity(teamID, type, amount)
    // - ResourceStorageContainer: actual storage objects
    // - Building: teamID must be set before Start()
    // ---------------------------------------------------------

    void Start()
    {
        started = true;
        Register();
    }

    void OnEnable()
    {
        if (started) Register();
    }

    void OnDisable()
    {
        if (registered) Unregister();
    }

    void Register()
    {
        if (registered) return;
        if (TeamStorageManager.Instance == null) return;

        if (capacities != null)
        {
            for (int i = 0; i < capacities.Length; i++)
            {
                int cap = Mathf.Max(0, capacities[i].capacity);
                if (cap > 0)
                    TeamStorageManager.Instance.AddCapacity(teamID, capacities[i].type, cap);
            }
        }

        registered = true;
    }

    void Unregister()
    {
        if (TeamStorageManager.Instance == null) return;

        if (capacities != null)
        {
            for (int i = 0; i < capacities.Length; i++)
            {
                int cap = Mathf.Max(0, capacities[i].capacity);
                if (cap > 0)
                    TeamStorageManager.Instance.RemoveCapacity(teamID, capacities[i].type, cap);
            }
        }

        registered = false;
    }

    public void RefreshRegistration()
    {
        if (!started) return;

        if (registered)
            Unregister();

        Register();
    }
}

==============================
FILE: Turret.cs
==============================

// =============================================================
// Turret.cs (Updated for WeaponComponent)
//
// DEPENDENCIES:
// - UnitCombatController:
//      * Handles targeting + stance logic.
// - WeaponComponent:
//      * Handles firing.
// - Attackable:
//      * Makes turret a valid target.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If turrets gain rotation, add a rotating base component.
// - If turrets gain multiple weapons, add a WeaponComponent[] array.
// =============================================================

using UnityEngine;

[RequireComponent(typeof(UnitCombatController))]
[RequireComponent(typeof(WeaponComponent))]
[RequireComponent(typeof(Attackable))]
public class Turret : MonoBehaviour
{
    public int teamID;

    void Awake()
    {
        GetComponent<UnitCombatController>().teamID = teamID;
        GetComponent<Attackable>().teamID = teamID;
    }
}

==============================
FILE: VehicleFactory.cs
==============================

using UnityEngine;

public class VehicleFactory : Building
{
    [Header("Vehicle Production")]
    public GameObject vehiclePrefab;
    public float buildSeconds = 10f;
    public ResourceCost[] buildCost;

    private float timer;
    private bool building;

    public void StartBuildVehicle()
    {
        if (building) return;
        if (TeamResources.Instance == null) return;
        if (vehiclePrefab == null) return;

        if (!TeamResources.Instance.CanAfford(teamID, buildCost)) return;
        if (!TeamResources.Instance.Spend(teamID, buildCost)) return;

        building = true;
        timer = 0f;
    }

    void Update()
    {
        if (!IsAlive) return;
        if (!building) return;

        timer += Time.deltaTime;
        if (timer >= buildSeconds)
        {
            building = false;
            Vector3 pos = transform.position + transform.forward * 4f;
            Instantiate(vehiclePrefab, pos, Quaternion.identity);
        }
    }
}


==============================
FILE: WeaponsFactory.cs
==============================

using UnityEngine;

public class WeaponsFactory : Building
{
    [Header("Crafting Output (adds to TeamInventory as tools/weapons)")]
    public ToolItem weaponTool;
    public float craftSeconds = 8f;

    private float timer;
    private bool crafting;

    public void StartCraft()
    {
        if (crafting) return;
        if (weaponTool == null) return;
        if (CraftingSystem.Instance == null) return;

        // Spend immediately via CraftingSystem (uses ToolItem.craftCost)
        bool ok = CraftingSystem.Instance.CraftTool(teamID, weaponTool, 1);
        if (!ok) return;

        // Optional: make it take time (we already spent cost)
        crafting = true;
        timer = 0f;
    }

    void Update()
    {
        if (!IsAlive) return;
        if (!crafting) return;

        timer += Time.deltaTime;
        if (timer >= craftSeconds)
        {
            crafting = false;
            // Tool already added by CraftingSystem; this timer is just “manufacturing time”
        }
    }
}


==============================
FILE: AutoDestroyFX.cs
==============================

using UnityEngine;

public class AutoDestroyFX : MonoBehaviour
{
    public float lifetime = 1.5f;

    void Start()
    {
        Destroy(gameObject, lifetime);
    }
}


==============================
FILE: Projectile.cs
==============================

// =============================================================
// Projectile.cs (Unified + Pooling Compatible)
//
// DEPENDENCIES:
// - Attackable:
//      * Must expose: teamID, IsAlive, TakeDamage(float)
// - ProjectilePool:
//      * Handles pooling.
// - WeaponComponent:
//      * Spawns this projectile.
//
// NOTES FOR FUTURE MAINTENANCE:
// - This is a homing projectile. For ballistic or physics-based,
//   replace Update() with Rigidbody logic.
// - If you add armor/resistance, wrap TakeDamage() in a damage system.
// =============================================================

using UnityEngine;

public class Projectile : MonoBehaviour
{
    [HideInInspector] public Projectile prefabKey;

    [Header("Movement")]
    public float speed = 25f;
    public float maxLifetime = 5f;

    [Header("FX")]
    public GameObject impactFX;

    private Attackable target;
    private float damage;
    private int sourceTeam;
    private float lifeTimer;

    public void Init(Attackable target, float damage, int teamID)
    {
        this.target = target;
        this.damage = damage;
        this.sourceTeam = teamID;
        lifeTimer = 0f;
    }

    void Update()
    {
        lifeTimer += Time.deltaTime;
        if (lifeTimer >= maxLifetime)
        {
            ProjectilePool.Instance.Despawn(this);
            return;
        }

        if (target == null || !target.IsAlive)
        {
            ProjectilePool.Instance.Despawn(this);
            return;
        }

        Vector3 dir = target.transform.position - transform.position;
        float dist = dir.magnitude;

        if (dist < 0.2f)
        {
            HitTarget();
            return;
        }

        transform.position += dir.normalized * speed * Time.deltaTime;
        transform.forward = dir.normalized;
    }

    void HitTarget()
    {
        if (target != null && target.IsAlive && target.teamID != sourceTeam)
            target.TakeDamage(damage);

        if (impactFX != null)
            Instantiate(impactFX, transform.position, Quaternion.identity);

        ProjectilePool.Instance.Despawn(this);
    }
}

==============================
FILE: TurretProjectile.cs
==============================

// =============================================================
// TurretProjectile.cs
//
// DEPENDENCIES:
// - TurretProjectilePool:
//      * Spawns and despawns this projectile.
// - Attackable (MonoBehaviour):
//      * Used to apply damage on impact (via TakeDamage or similar).
//
// NOTES FOR FUTURE MAINTENANCE:
// - Right now this is a standalone projectile system, separate from the
//   Projectile used by UnitCombatController.
// - If you want turrets to use this instead of the generic Projectile,
//   wire Turret / UnitCombatController to spawn TurretProjectile via the pool.
// - Ensure Attackable has a damage API compatible with this script.
// =============================================================

using UnityEngine;

public class TurretProjectile : MonoBehaviour
{
    [HideInInspector] public TurretProjectile prefabKey;

    private Transform target;
    private float damage;
    private float speed;
    private float life;
    private int ownerTeamID;

    /// <summary>
    /// Initialize the projectile.
    /// </summary>
    public void Init(int ownerTeamID, Transform targetTf, float dmg, float spd)
    {
        this.ownerTeamID = ownerTeamID;
        target = targetTf;
        damage = dmg;
        speed = spd;
        life = 2.0f;
    }

    void Update()
    {
        life -= Time.deltaTime;
        if (life <= 0f)
        {
            TurretProjectilePool.Instance.Despawn(this);
            return;
        }

        if (target == null)
        {
            TurretProjectilePool.Instance.Despawn(this);
            return;
        }

        Vector3 dir = target.position - transform.position;
        float dist = dir.magnitude;

        if (dist < 0.25f)
        {
            // Apply damage on impact if target has an Attackable component.
            var atk = target.GetComponentInParent<Attackable>();
            if (atk != null && atk.IsAlive && atk.teamID != ownerTeamID)
            {
                atk.TakeDamage(damage);
            }

            TurretProjectilePool.Instance.Despawn(this);
            return;
        }

        transform.position += dir.normalized * (speed * Time.deltaTime);
        transform.forward = dir.normalized;
    }
}

==============================
FILE: Attackable.cs
==============================

// ============================================================================
// Attackable.cs
//
// PURPOSE:
// - Universal health + damage interface for ANY object that can be attacked.
// - Used by units, civilians, buildings, turrets, and future entities.
// - Provides a consistent API for combat, AI, UI, and projectiles.
//
// DEPENDENCIES:
// - IHasHealth:
//      * Interface requiring CurrentHealth, MaxHealth.
// - UnitCombatController / WeaponComponent:
//      * Query IsAlive, teamID, isCivilian, isBuilding.
//      * Call TakeDamage() when projectiles hit.
// - Projectile / ProjectilePool:
//      * Calls TakeDamage() on impact.
// - AIMilitary:
//      * Uses isCivilian / isBuilding for targeting bias.
// - UnitInspectorUI:
//      * Reads health values and teamID.
// - Building:
//      * If present, Attackable auto-marks itself as a building.
// - AlertManager:
//      * Displays "under attack" and "destroyed" notifications.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add armor/resistance, wrap TakeDamage() in a damage calculation layer.
// - If you add death animations, replace Destroy(gameObject) with an animation
//   event or death handler.
// - If you add repair drones or engineers, ensure Repair() remains safe to call.
// - If you add factions or diplomacy, ensure teamID integrates with DiplomacyManager.
// - If you add shields, add a shield layer BEFORE currentHealth is reduced.
// - If you add pooling for buildings/units, replace Destroy() with a pool return.
// ============================================================================

using UnityEngine;

public class Attackable : MonoBehaviour, IHasHealth
{
    [Header("Team & Classification")]
    public int teamID;
    public bool isCivilian;
    public bool isBuilding;   // Used by AIMilitary personality bias

    [Header("Health")]
    public float maxHealth = 100f;
    float currentHealth;

    [Header("Repair")]
    public bool canBeRepaired = true;

    // IHasHealth interface
    public bool IsAlive => currentHealth > 0;
    public float CurrentHealth => currentHealth;
    public float MaxHealth => maxHealth;

    // Helper property
    public bool IsDamaged => IsAlive && currentHealth < maxHealth;

    void Awake()
    {
        currentHealth = maxHealth;

        // Auto-detect buildings
        if (GetComponent<Building>() != null)
            isBuilding = true;
    }

    // ------------------------------------------------------------------------
    // Damage & Repair
    // ------------------------------------------------------------------------

    public void Repair(float amount)
    {
        if (!canBeRepaired || !IsAlive) return;
        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);
    }

    public void TakeDamage(float dmg)
    {
        if (!IsAlive) return;

        currentHealth -= dmg;

        // Alert system
        if (AlertManager.Instance != null)
        {
            AlertManager.Instance.Push($"{name} is under attack!");
        }

        if (currentHealth <= 0)
            Die();
    }

    void Die()
    {
        if (AlertManager.Instance != null)
        {
            AlertManager.Instance.Push($"{name} destroyed");
        }

        // NOTE: If you add death animations or pooling, replace this.
        Destroy(gameObject);
    }
}

==============================
FILE: Civilian.cs
==============================

using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent))]
public class Civilian : MonoBehaviour, ITargetable, IHasHealth
{
    [Header("Team")]
    public int teamID;

    [Header("Role")]
    public CivilianRole role = CivilianRole.Gatherer;

    [Header("Health")]
    public float maxHealth = 50f;

    [Header("Movement")]
    public float speed = 2.5f;
    public float stopDistance = 1.2f;

    [Header("Carrying")]
    public int carryCapacity = 30;

    [Header("Gathering")]
    public float gatherTickSeconds = 0.8f;
    public int harvestPerTick = 10;
    public float searchRetrySeconds = 1.5f;

    [Header("Building/Hauling")]
    public bool buildersCanHaulMaterials = true;
    public float retargetSeconds = 0.6f;

    // Compatibility fields referenced elsewhere
    public ResourceNode CurrentReservedNode { get; set; }
    public ConstructionSite CurrentAssignedSite { get; set; }
    public ConstructionSite CurrentDeliverySite { get; set; }

    // Expose carried for UI
    public ResourceType CarriedType => carriedType;
    public int CarriedAmount => carriedAmount;

    private float currentHealth;
    private NavMeshAgent agent;

    private ResourceType carriedType;
    private int carriedAmount;

    // Legacy/compat fields (kept for external references)
    public bool HasJob;
    public ResourceNode CurrentNode;

    private float gatherTimer;
    private float searchTimer;
    private float retargetTimer;

    private ResourceNode targetNode;
    private ConstructionSite targetSite;
    private ResourceStorageContainer targetStorage;

    // IHasHealth / ITargetable style properties
    public int TeamID => teamID;
    public bool IsAlive => currentHealth > 0f;

    public float CurrentHealth => currentHealth;
    public float MaxHealth => maxHealth;

    private enum State
    {
        Idle,

        SearchingNode,
        GoingToNode,
        Gathering,
        GoingToDepositStorage,
        Depositing,

        SearchingBuildSite,
        GoingToBuildSite,
        Building,

        SearchingSupplySite,
        GoingToPickupStorage,
        PickingUp,
        GoingToDeliverSite,
        Delivering
    }

    private State state;

    // Registration timing: teamID is often assigned right after Instantiate (before Start).
    // So we register with JobManager in Start, and only re-register on OnEnable if Start has run.
    private bool started;
    private bool registeredWithJobManager;

    void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
        agent.updateRotation = true;
        agent.autoBraking = true;
    }

    void OnEnable()
    {
        // Only register here if Start has already run (prevents wrong-team registration on Instantiate)
        if (started)
            RegisterWithJobManager();
    }

    void OnDisable()
    {
        if (registeredWithJobManager)
            UnregisterFromJobManager();
    }

    void Start()
    {
        currentHealth = maxHealth;
        SetRole(role);

        started = true;
        RegisterWithJobManager();
    }

    void RegisterWithJobManager()
    {
        if (registeredWithJobManager) return;
        if (JobManager.Instance == null) return;
        JobManager.Instance.RegisterCivilian(this);
        registeredWithJobManager = true;
    }

    void UnregisterFromJobManager()
    {
        if (!registeredWithJobManager) return;
        if (JobManager.Instance != null)
            JobManager.Instance.UnregisterCivilian(this);
        registeredWithJobManager = false;
    }

    /// <summary>
    /// Call this if you change teamID at runtime and want the TaskBoard counts to move teams.
    /// </summary>
    public void RefreshJobManagerRegistration()
    {
        if (!started) return;

        if (registeredWithJobManager)
            UnregisterFromJobManager();

        RegisterWithJobManager();
    }

    void Update()
    {
        if (!IsAlive) return;

        agent.speed = speed;
        agent.stoppingDistance = stopDistance;

        switch (state)
        {
            case State.Idle: break;

            case State.SearchingNode: TickSearchNode(); break;
            case State.GoingToNode: TickGoNode(); break;
            case State.Gathering: TickGather(); break;
            case State.GoingToDepositStorage: TickGoDeposit(); break;
            case State.Depositing: TickDeposit(); break;

            case State.SearchingBuildSite: TickSearchBuildSite(); break;
            case State.GoingToBuildSite: TickGoBuildSite(); break;
            case State.Building: TickBuild(); break;

            case State.SearchingSupplySite: TickSearchSupplySite(); break;
            case State.GoingToPickupStorage: TickGoPickup(); break;
            case State.PickingUp: TickPickup(); break;
            case State.GoingToDeliverSite: TickGoDeliver(); break;
            case State.Delivering: TickDeliver(); break;
        }
    }

    public void SetRole(CivilianRole newRole)
    {
        role = newRole;

        targetNode = null;
        targetSite = null;
        targetStorage = null;

        CurrentReservedNode = null;
        CurrentAssignedSite = null;
        CurrentDeliverySite = null;

        if (carriedAmount > 0)
        {
            // keep carried as-is, we'll deposit next tick
            state = State.GoingToDepositStorage;
            return;
        }

        switch (role)
        {
            case CivilianRole.Gatherer: state = State.SearchingNode; break;
            case CivilianRole.Builder: state = State.SearchingBuildSite; break;
            case CivilianRole.Hauler: state = State.SearchingSupplySite; break;
            default: state = State.Idle; break;
        }
    }

    /// <summary>
    /// Explicit job assignment from AI/job system.
    /// Forces this civilian into gatherer behaviour on a specific node.
    /// </summary>
    public void AssignGatherJob(ResourceNode node)
    {
        HasJob = node != null;
        CurrentNode = node;

        carriedAmount = 0;
        targetSite = null;
        targetStorage = null;

        CurrentAssignedSite = null;
        CurrentDeliverySite = null;

        role = CivilianRole.Gatherer;
        targetNode = node;
        CurrentReservedNode = node;

        if (targetNode != null)
        {
            state = State.GoingToNode;
            agent.SetDestination(targetNode.transform.position);
        }
        else
        {
            state = State.SearchingNode;
        }
    }

    // ---------- Gatherer ----------

    void TickSearchNode()
    {
        searchTimer += Time.deltaTime;
        if (searchTimer < searchRetrySeconds) return;
        searchTimer = 0f;

        targetNode = FindClosestResourceNode();
        CurrentReservedNode = targetNode;

        if (targetNode != null)
        {
            state = State.GoingToNode;
            agent.SetDestination(targetNode.transform.position);
        }
    }

    void TickGoNode()
    {
        if (targetNode == null || targetNode.amount <= 0)
        {
            targetNode = null;
            CurrentReservedNode = null;
            state = State.SearchingNode;
            return;
        }

        retargetTimer += Time.deltaTime;
        if (retargetTimer >= retargetSeconds)
        {
            retargetTimer = 0f;
            agent.SetDestination(targetNode.transform.position);
        }

        if (Arrived())
        {
            state = State.Gathering;
            gatherTimer = 0f;
        }
    }

    void TickGather()
    {
        if (targetNode == null || targetNode.amount <= 0)
        {
            targetNode = null;
            CurrentReservedNode = null;
            state = (carriedAmount > 0) ? State.GoingToDepositStorage : State.SearchingNode;
            return;
        }

        gatherTimer += Time.deltaTime;
        if (gatherTimer < gatherTickSeconds) return;
        gatherTimer = 0f;

        if (carriedAmount == 0) carriedType = targetNode.type;
        if (carriedType != targetNode.type)
        {
            state = State.GoingToDepositStorage;
            return;
        }

        int remaining = GetCarryCapacity() - carriedAmount;
        if (remaining <= 0)
        {
            state = State.GoingToDepositStorage;
            return;
        }

        // Must have physical storage free to avoid “phantom resources”
        if (TeamStorageManager.Instance != null)
        {
            var s = TeamStorageManager.Instance.FindNearestStorageWithFree(teamID, carriedType, transform.position);
            if (s == null || s.GetFree(carriedType) <= 0)
            {
                state = State.GoingToDepositStorage;
                return;
            }
        }

        int want = Mathf.Min(GetHarvestPerTick(), remaining);
        int got = targetNode.Harvest(want);
        if (got > 0) carriedAmount += got;

        if (carriedAmount >= GetCarryCapacity())
            state = State.GoingToDepositStorage;
    }

    void TickGoDeposit()
    {
        if (carriedAmount <= 0)
        {
            state = State.SearchingNode;
            return;
        }

        if (TeamStorageManager.Instance == null)
        {
            // fallback: dump into TeamResources primary storage
            TeamResources.Instance?.Deposit(teamID, carriedType, carriedAmount);
            carriedAmount = 0;
            state = (role == CivilianRole.Gatherer) ? State.SearchingNode : State.SearchingBuildSite;
            return;
        }

        if (targetStorage == null || targetStorage.teamID != teamID)
            targetStorage = TeamStorageManager.Instance.FindNearestStorageWithFree(teamID, carriedType, transform.position);

        if (targetStorage == null)
            return;

        agent.SetDestination(targetStorage.transform.position);

        if (Arrived())
            state = State.Depositing;
    }

    void TickDeposit()
    {
        if (targetStorage == null || carriedAmount <= 0)
        {
            state = (role == CivilianRole.Gatherer) ? State.SearchingNode : State.SearchingBuildSite;
            return;
        }

        int accepted = targetStorage.Deposit(carriedType, carriedAmount);
        carriedAmount -= accepted;

        // If storage was full, drop remaining (simple)
        if (carriedAmount > 0) carriedAmount = 0;

        targetStorage = null;
        state = (role == CivilianRole.Gatherer) ? State.SearchingNode : State.SearchingBuildSite;
    }

    // ---------- Builder ----------

    void TickSearchBuildSite()
    {
        searchTimer += Time.deltaTime;
        if (searchTimer < searchRetrySeconds) return;
        searchTimer = 0f;

        targetSite = FindNearestConstructionSite(teamID, transform.position);
        CurrentAssignedSite = targetSite;

        if (targetSite == null) return;

        if (!targetSite.MaterialsComplete && buildersCanHaulMaterials)
        {
            state = State.SearchingSupplySite;
            return;
        }

        state = State.GoingToBuildSite;
        agent.SetDestination(targetSite.transform.position);
    }

    void TickGoBuildSite()
    {
        if (targetSite == null || targetSite.IsComplete)
        {
            targetSite = null;
            CurrentAssignedSite = null;
            state = State.SearchingBuildSite;
            return;
        }

        if (!targetSite.MaterialsComplete)
        {
            state = buildersCanHaulMaterials ? State.SearchingSupplySite : State.SearchingBuildSite;
            return;
        }

        agent.SetDestination(targetSite.transform.position);
        if (Arrived()) state = State.Building;
    }

    void TickBuild()
    {
        if (targetSite == null || targetSite.IsComplete)
        {
            targetSite = null;
            CurrentAssignedSite = null;
            state = State.SearchingBuildSite;
            return;
        }

        if (!targetSite.MaterialsComplete)
        {
            state = buildersCanHaulMaterials ? State.SearchingSupplySite : State.SearchingBuildSite;
            return;
        }

        targetSite.AddWork(Time.deltaTime * Mathf.Max(0.25f, GetBuildMultiplier()));
    }

    // ---------- Hauler / Supply to Construction ----------

    void TickSearchSupplySite()
    {
        if (carriedAmount > 0 && targetSite != null)
        {
            state = State.GoingToDeliverSite;
            return;
        }

        searchTimer += Time.deltaTime;
        if (searchTimer < searchRetrySeconds) return;
        searchTimer = 0f;

        targetSite = FindNearestConstructionSite(teamID, transform.position);
        CurrentDeliverySite = targetSite;

        if (targetSite == null) return;
        if (targetSite.IsComplete || targetSite.MaterialsComplete)
        {
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        if (!TryChooseNeededResource(targetSite, out carriedType))
        {
            targetSite = null;
            CurrentDeliverySite = null;
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        state = State.GoingToPickupStorage;
    }

    void TickGoPickup()
    {
        if (TeamStorageManager.Instance == null || targetSite == null)
        {
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        // Only pick up up to what is reserved for this site
        int reservedForSite = TeamStorageManager.Instance.GetReservedForSite(targetSite.SiteKey, carriedType);
        if (reservedForSite <= 0)
        {
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        if (targetStorage == null)
            targetStorage = TeamStorageManager.Instance.FindNearestStorageWithStored(teamID, carriedType, transform.position);

        if (targetStorage == null)
            return;

        agent.SetDestination(targetStorage.transform.position);

        if (Arrived())
            state = State.PickingUp;
    }

    void TickPickup()
    {
        if (TeamStorageManager.Instance == null || targetStorage == null || targetSite == null)
        {
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        int missing = targetSite.GetMissing(carriedType);
        int reservedForSite = TeamStorageManager.Instance.GetReservedForSite(targetSite.SiteKey, carriedType);

        int want = Mathf.Min(GetCarryCapacity(), missing);
        want = Mathf.Min(want, reservedForSite);

        if (want <= 0)
        {
            targetStorage = null;
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        int took = targetStorage.Withdraw(carriedType, want);
        if (took <= 0)
        {
            targetStorage = null;
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        // Reduce reservation as soon as the resources are physically removed from storage
        TeamStorageManager.Instance.ConsumeReserved(teamID, targetSite.SiteKey, carriedType, took);

        carriedAmount = took;

        targetStorage = null;
        state = State.GoingToDeliverSite;
        agent.SetDestination(targetSite.transform.position);
    }

    void TickGoDeliver()
    {
        if (targetSite == null)
        {
            state = State.GoingToDepositStorage;
            return;
        }

        agent.SetDestination(targetSite.transform.position);
        if (Arrived()) state = State.Delivering;
    }

    void TickDeliver()
    {
        if (targetSite == null || carriedAmount <= 0)
        {
            state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
            return;
        }

        int accepted = targetSite.ReceiveDelivery(carriedType, carriedAmount);
        carriedAmount -= accepted;

        if (carriedAmount > 0)
        {
            // if somehow couldn’t accept, put it back into storage
            state = State.GoingToDepositStorage;
            return;
        }

        state = (role == CivilianRole.Builder) ? State.SearchingBuildSite : State.SearchingSupplySite;
    }

    // ---------- Helpers ----------

    bool Arrived()
    {
        if (agent.pathPending) return false;
        if (agent.remainingDistance == Mathf.Infinity) return false;
        return agent.remainingDistance <= agent.stoppingDistance + 0.15f;
    }

    int GetCarryCapacity()
    {
        CharacterStats stats = GetComponent<CharacterStats>();
        if (stats != null && stats.CarryCapacity > 0) return stats.CarryCapacity;
        return carryCapacity;
    }

    int GetHarvestPerTick()
    {
        CharacterStats stats = GetComponent<CharacterStats>();
        if (stats != null && stats.HarvestPerTick > 0) return stats.HarvestPerTick;
        return harvestPerTick;
    }

    float GetBuildMultiplier()
    {
        CharacterStats stats = GetComponent<CharacterStats>();
        if (stats != null) return stats.BuildWorkMultiplier;
        return 1f;
    }

    ResourceNode FindClosestResourceNode()
    {
        var nodes = FindObjectsOfType<ResourceNode>();
        ResourceNode best = null;
        float bestD = float.MaxValue;

        for (int i = 0; i < nodes.Length; i++)
        {
            var n = nodes[i];
            if (n == null || n.amount <= 0) continue;

            float d = (n.transform.position - transform.position).sqrMagnitude;
            if (d < bestD)
            {
                bestD = d;
                best = n;
            }
        }

        return best;
    }

    ConstructionSite FindNearestConstructionSite(int team, Vector3 pos)
    {
        ConstructionSite[] sites = FindObjectsOfType<ConstructionSite>();
        ConstructionSite best = null;
        float bestD = float.MaxValue;

        for (int i = 0; i < sites.Length; i++)
        {
            var s = sites[i];
            if (s == null) continue;
            if (s.teamID != team) continue;
            if (s.IsComplete) continue;

            float d = (s.transform.position - pos).sqrMagnitude;
            if (d < bestD)
            {
                bestD = d;
                best = s;
            }
        }

        return best;
    }

    bool TryChooseNeededResource(ConstructionSite site, out ResourceType neededType)
    {
        neededType = default;
        if (site == null) return false;

        ResourceCost[] costs = site.GetRequiredCosts();
        if (costs == null || costs.Length == 0) return false;

        int bestMissing = 0;
        ResourceType bestType = costs[0].type;

        for (int i = 0; i < costs.Length; i++)
        {
            int missing = site.GetMissing(costs[i].type);
            if (missing > bestMissing)
            {
                bestMissing = missing;
                bestType = costs[i].type;
            }
        }

        if (bestMissing <= 0) return false;

        neededType = bestType;
        return true;
    }

    public void TakeDamage(float damage)
    {
        if (!IsAlive) return;

        currentHealth -= damage;
        if (currentHealth <= 0f)
        {
            currentHealth = 0f;
            if (agent != null) agent.isStopped = true;
            Destroy(gameObject);
        }
    }

    // If your ITargetable interface expects something like this, you can keep it:
    public Transform GetTransform()
    {
        return transform;
    }
}

==============================
FILE: TeamVisual.cs
==============================

using UnityEngine;

/// <summary>
/// TeamVisual
///
/// PURPOSE:
/// - Applies team-based visuals (colors, materials, decals, etc.)
///   to units, civilians, and buildings.
/// - Delegates styling to SciFiTeamStyler if present, otherwise
///   falls back to simple color tinting via TeamColorManager.
///
/// DEPENDENCIES:
/// - SciFiTeamStyler (optional):
///     * Centralized styling system for meshes, materials, emissives,
///       decals, etc.
///     * Must expose: void Apply(GameObject obj, int teamID, VisualKind kind).
/// - TeamColorManager (optional fallback):
///     * Simple color tinting using Renderer.material.color.
/// - Team.cs:
///     * teamID is usually assigned from Team / Building / Unit.
/// - Building / Unit / Civilian:
///     * These components typically own the teamID that should be
///       mirrored here.
///
/// NOTES FOR FUTURE MAINTENANCE:
/// - This script NEVER deletes teams or GameObjects.
/// - Safe to put on any prefab that needs team visuals.
/// - If you add new visual kinds (e.g., Vehicle, StructureAddon),
///   extend VisualKind and update SciFiTeamStyler accordingly.
/// - If you move away from a global SciFiTeamStyler, you can inject
///   styling via another system and keep this as a thin adapter.
/// - applyOnStart is useful for prefabs; for pooled objects you may
///   want to call Apply() manually after teamID is set.
///
/// ARCHITECTURE:
/// - Runs once on Start() if applyOnStart is true.
/// - Purely visual; no gameplay logic, no resource logic, no deletion.
/// </summary>
public enum VisualKind { Unit, Civilian, Building }

public class TeamVisual : MonoBehaviour
{
    public int teamID;
    public VisualKind kind = VisualKind.Unit;
    public bool applyOnStart = true;

    void Start()
    {
        if (applyOnStart) Apply();
    }

    public void Apply()
    {
        if (SciFiTeamStyler.Instance != null)
            SciFiTeamStyler.Instance.Apply(gameObject, teamID, kind);
        else if (TeamColorManager.Instance != null)
            TeamColorManager.Instance.ApplyTeamColor(gameObject, teamID); // fallback
    }
}

==============================
FILE: Unit.cs
==============================

using UnityEngine;
using UnityEngine.AI;

/// <summary>
/// Base class for all units in Cube Wars.
///
/// DEPENDENCIES:
/// - NavMeshAgent:
///     Movement and pathfinding.
/// - UnitCombatController:
///     Handles combat behaviour.
/// - AIMilitary:
///     Issues MoveTo commands.
/// - IHasHealth / IAttackable:
///     Used by UI, AI, and combat systems.
///
/// RESPONSIBILITIES:
/// - Movement
/// - Health + damage
/// - Combat targeting info
///
/// IMPORTANT:
/// - Does NOT delete teams.
/// - Only destroys THIS unit on death.
/// </summary>
public class Unit : MonoBehaviour, IHasHealth, IAttackable
{
    [Header("Team")]
    public int teamID;

    [Header("Combat")]
    public bool combatEnabled = true;
    public float attackRange = 5f;
    public float damage = 10f;

    [Header("Health")]
    public float MaxHealth = 100f;
    public float CurrentHealth = 100f;

    private NavMeshAgent agent;

    void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
        if (agent != null)
        {
            agent.stoppingDistance = 0.5f;
            agent.updateRotation = true;
        }
    }

    public void MoveTo(Vector3 pos)
    {
        if (agent == null) return;
        agent.isStopped = false;
        agent.SetDestination(pos);
    }

    float IHasHealth.CurrentHealth => CurrentHealth;
    float IHasHealth.MaxHealth => MaxHealth;

    public int TeamID => teamID;
    public bool IsAlive => CurrentHealth > 0f;
    public Transform AimPoint => transform;

    public void TakeDamage(float amount)
    {
        if (!IsAlive) return;

        CurrentHealth -= amount;
        if (CurrentHealth <= 0f)
        {
            CurrentHealth = 0f;
            Die();
        }
    }

    void Die()
    {
        Destroy(gameObject);
    }
}

==============================
FILE: AIBuilder.cs
==============================

using UnityEngine;

public class AIBuilder : MonoBehaviour
{
    public int teamID;
    public AIPersonality personality;

    [Header("Build Options")]
    public BuildItemDefinition[] availableBuildings;
    public float buildRadius = 18f;
    public float buildCooldown = 8f;

    float buildTimer;

    void Update()
    {
        buildTimer -= Time.deltaTime;
    }

    public void Tick()
    {
        if (buildTimer > 0f)
            return;

        BuildItemDefinition choice = ChooseBuilding();
        if (choice == null)
            return;

        Vector3 pos;
        if (!FindBuildLocation(out pos))
            return;

        if (!TeamResources.Instance.CanAfford(teamID, choice.costs))
            return;

        BuildPlacementManager.Instance.PlaceBuild(
            choice,
            pos,
            Quaternion.identity,
            teamID
        );

        buildTimer = buildCooldown;
    }

    BuildItemDefinition ChooseBuilding()
    {
        if (availableBuildings == null || availableBuildings.Length == 0)
            return null;

        switch (personality)
        {
            case AIPersonality.Aggressive:
                return FindBuilding(AIBuildingPriority.Military);

            case AIPersonality.Defensive:
                return FindBuilding(AIBuildingPriority.Storage);

            default:
                return FindBuilding(AIBuildingPriority.Economy);
        }
    }

    BuildItemDefinition FindBuilding(AIBuildingPriority priority)
    {
        foreach (var b in availableBuildings)
        {
            if (b.aiPriority == priority)
                return b;
        }

        return availableBuildings[Random.Range(0, availableBuildings.Length)];
    }

    bool FindBuildLocation(out Vector3 pos)
    {
        pos = Vector3.zero;

        Vector3 origin = FindBaseCenter();
        if (origin == Vector3.zero)
            return false;

        for (int i = 0; i < 20; i++)
        {
            Vector2 r = Random.insideUnitCircle * buildRadius;
            Vector3 p = origin + new Vector3(r.x, 0f, r.y);

            if (BuildPlacementManager.Instance.CanPlaceAt(p))
            {
                pos = p;
                return true;
            }
        }

        return false;
    }

    Vector3 FindBaseCenter()
    {
        foreach (var s in GameObject.FindObjectsOfType<ResourceStorageContainer>())
        {
            if (s.teamID == teamID)
                return s.transform.position;
        }

        return Vector3.zero;
    }
}
// DEPENDENCIES:
// - Requires BuildPlacementManager.PlaceBuild(...) and TeamResources.CanAfford/Spend.


==============================
FILE: AIBuildingPriority.cs
==============================

public enum AIBuildingPriority
{
    Economy,
    Military,
    Storage
}


==============================
FILE: AIEconomy.cs
==============================

// =============================================================
// AIEconomy.cs
//
// DEPENDENCIES:
// - Barracks: uses QueueCount, EnqueueUnit(), buildTime proxy
// - AIPersonality: affects delay between unit queues
//
// NOTES FOR FUTURE MAINTENANCE:
// - If Barracks changes how units are produced, keep this in sync.
// - For more advanced AI, replace EnqueueUnit() with explicit unit selection.
// =============================================================

using UnityEngine;

public class AIEconomy : MonoBehaviour
{
    public int teamID;
    public AIPersonality personality;

    [Header("Behaviour")]
    public float buildDelayMultiplier = 1f;
    public float minQueueDelay = 0.5f;

    private Barracks barracks;
    private float buildTimer;

    void Start()
    {
        FindBarracks();
    }

    void FindBarracks()
    {
        foreach (var b in GameObject.FindObjectsOfType<Barracks>())
        {
            if (b.teamID == teamID)
            {
                barracks = b;
                return;
            }
        }
    }

    public void Tick()
    {
        if (barracks == null)
        {
            FindBarracks();
            return;
        }

        buildTimer -= Time.deltaTime;
        if (buildTimer > 0f) return;

        if (barracks.QueueCount == 0)
        {
            barracks.EnqueueUnit();

            float baseTime = barracks.buildTime;
            float personalityFactor = 1f;

            switch (personality)
            {
                case AIPersonality.Aggressive:
                    personalityFactor = 0.8f;
                    break;
                case AIPersonality.Defensive:
                    personalityFactor = 1.2f;
                    break;
                default:
                    personalityFactor = 1f;
                    break;
            }

            buildTimer = Mathf.Max(
                minQueueDelay,
                baseTime * buildDelayMultiplier * personalityFactor
            );
        }
    }
}

==============================
FILE: AIMilitary.cs
==============================

using UnityEngine;

public class AIMilitary : MonoBehaviour
{
    public int teamID;
    public AIPersonality personality;

    [Header("Attack Rules")]
    public int attackThreshold = 4;
    public float attackRange = 40f;

    // -----------------------------
    // DEPENDENCIES:
    // - Unit: must implement MoveTo(Vector3)
    // - UnitCombatController: used for combat targeting
    // - DiplomacyManager: used for war checks
    // - Attackable: enemy target interface
    // -----------------------------

    public void DefendLocation(Vector3 pos)
    {
        Unit[] units = GameObject.FindObjectsOfType<Unit>();

        foreach (var u in units)
        {
            if (u.teamID != teamID) continue;
            if (!u.combatEnabled) continue;

            u.MoveTo(pos);
            return; // send ONE unit
        }
    }

    public void Tick()
    {
        UnitCombatController[] units = GameObject.FindObjectsOfType<UnitCombatController>();
        int myUnits = 0;

        foreach (var u in units)
            if (u.teamID == teamID)
                myUnits++;

        if (myUnits < attackThreshold)
            return;

        Attackable target = FindEnemyTarget();
        if (target == null) return;

        foreach (var unit in units)
        {
            if (unit.teamID != teamID) continue;
            unit.SetManualTarget(target);
        }
    }

    Attackable FindEnemyTarget()
    {
        Attackable[] all = GameObject.FindObjectsOfType<Attackable>();
        Attackable best = null;
        float bestDist = float.MaxValue;

        foreach (var a in all)
        {
            if (!a.IsAlive) continue;
            if (a.teamID == teamID) continue;

            if (!DiplomacyManager.Instance.AreAtWar(teamID, a.teamID))
                continue;

            float score = Vector3.Distance(transform.position, a.transform.position);

            // Personality bias
            if (personality == AIPersonality.Aggressive && a.isCivilian)
                score *= 0.7f;

            if (personality == AIPersonality.Defensive && !a.isBuilding)
                score *= 1.3f;

            if (score < bestDist && score <= attackRange)
            {
                bestDist = score;
                best = a;
            }
        }

        return best;
    }
}

==============================
FILE: AIPlayer.cs
==============================

using UnityEngine;

/// <summary>
/// Core AI controller for a single AI team.
/// 
/// DEPENDENCIES:
/// - AIEconomy
/// - AIMilitary
/// - AIBuilder
/// - AIResourceManager
/// - AIThreatDetector (optional)
/// - AIRepairManager (optional)
/// - AIRebuildManager (optional)
///
/// RESPONSIBILITIES:
/// - Tick all AI subsystems
/// - Apply difficulty settings
/// - Forward teamID and personality to subsystems
///
/// IMPORTANT:
/// - This script does NOT create or destroy teams.
/// - It only runs logic for the team it is attached to.
/// </summary>
[RequireComponent(typeof(AIEconomy))]
[RequireComponent(typeof(AIMilitary))]
[RequireComponent(typeof(AIBuilder))]
[RequireComponent(typeof(AIResourceManager))]
[RequireComponent(typeof(AIThreatDetector))]
public class AIPlayer : MonoBehaviour
{
    [Header("Team")]
    [Tooltip("Team ID this AI controls.")]
    public int teamID;

    [Header("AI Settings")]
    public AIDifficulty difficulty = AIDifficulty.Normal;
    public AIPersonality personality = AIPersonality.Balanced;

    float thinkInterval = 2f;
    float timer;

    AIEconomy economy;
    AIMilitary military;
    AIBuilder builder;
    AIResourceManager resourceManager;
    AIThreatDetector threatDetector;
    AIRepairManager repairManager;
    AIRebuildManager rebuildManager;

    void Awake()
    {
        // Cache subsystem references
        economy = GetComponent<AIEconomy>();
        military = GetComponent<AIMilitary>();
        builder = GetComponent<AIBuilder>();
        resourceManager = GetComponent<AIResourceManager>();
        threatDetector = GetComponent<AIThreatDetector>();
        repairManager = GetComponent<AIRepairManager>();
        rebuildManager = GetComponent<AIRebuildManager>();

        // Forward teamID to all subsystems
        economy.teamID = teamID;
        military.teamID = teamID;
        builder.teamID = teamID;
        resourceManager.teamID = teamID;
        if (threatDetector != null) threatDetector.teamID = teamID;
        if (repairManager != null) repairManager.teamID = teamID;
        if (rebuildManager != null) rebuildManager.teamID = teamID;

        // Forward personality
        economy.personality = personality;
        military.personality = personality;
        builder.personality = personality;

        ApplyDifficulty();
    }

    void ApplyDifficulty()
    {
        switch (difficulty)
        {
            case AIDifficulty.Easy:
                thinkInterval = 3f;
                break;
            case AIDifficulty.Hard:
                thinkInterval = 1.2f;
                break;
            default:
                thinkInterval = 2f;
                break;
        }
    }

    void Update()
    {
        timer -= Time.deltaTime;
        if (timer > 0f) return;

        timer = thinkInterval;

        // Tick all AI subsystems
        economy.Tick();
        builder.Tick();
        resourceManager.Tick();
        if (rebuildManager != null) rebuildManager.Tick();
        if (repairManager != null) repairManager.Tick();
        military.Tick();
    }
}

==============================
FILE: MultiTeamAIDirector.cs
==============================

using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// High-level AI director for multiple AI teams.
/// 
/// DEPENDENCIES:
/// - BuildGridCell
/// - BuildPlacementManager
/// - BuildItemDefinition
/// - BuildItemInstance
/// - ConstructionSite
/// - TeamResources
/// - Headquarters
///
/// RESPONSIBILITIES:
/// - Compute AI build strategy per team
/// - Reserve walkways
/// - Place buildings based on aggression
/// - Track construction sites
///
/// IMPORTANT:
/// - This script does NOT delete teams.
/// - It only reads teamID and HQ positions.
/// </summary>
public class MultiTeamAIDirector : MonoBehaviour
{
    // (rest of your script unchanged)
}

==============================
FILE: TeamAIBuild.cs
==============================

using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Handles AI building placement for a single team.
/// 
/// DEPENDENCIES:
/// - BuildGridCell
/// - BuildPlacementManager
/// - BuildCatalog
/// - TeamResources
///
/// RESPONSIBILITIES:
/// - Periodically attempt to place buildings
/// - Choose affordable items
/// - Respect category priorities
///
/// IMPORTANT:
/// - Does NOT delete teams
/// - Does NOT modify team objects
/// </summary>
public class TeamAIBuild : MonoBehaviour
{
    [Header("Team")]
    public int teamID = 1;
    public int playerTeamID = 0;

    [Header("Build Settings")]
    public BuildCatalog catalog;
    public float buildInterval = 4f;

    [Tooltip("Categories the AI will try in order.")]
    public List<string> categoryPriority = new List<string> { "Economy", "Industry", "Housing", "Tech" };

    private float timer;

    void Update()
    {
        if (teamID == playerTeamID) return;
        if (catalog == null) return;

        timer += Time.deltaTime;
        if (timer < buildInterval) return;
        timer = 0f;

        TryBuildSomething();
    }

    void TryBuildSomething()
    {
        BuildGridCell cell = FindFreeCellForTeam(teamID);
        if (cell == null) return;

        BuildItemDefinition chosen = ChooseAffordableItem(teamID);
        if (chosen == null) return;

        if (BuildPlacementManager.Instance != null)
            BuildPlacementManager.Instance.TryPlace(cell, chosen);
    }

    BuildGridCell FindFreeCellForTeam(int t)
    {
        var cells = FindObjectsOfType<BuildGridCell>();
        for (int i = 0; i < cells.Length; i++)
        {
            if (cells[i].teamID == t && !cells[i].isOccupied)
                return cells[i];
        }
        return null;
    }

    BuildItemDefinition ChooseAffordableItem(int t)
    {
        foreach (var cat in categoryPriority)
        {
            foreach (var item in catalog.items)
            {
                if (item == null) continue;
                if (!CategoryMatch(item.category, cat)) continue;

                if (TeamResources.Instance == null || TeamResources.Instance.CanAfford(t, item.costs))
                    return item;
            }
        }

        foreach (var item in catalog.items)
        {
            if (item == null) continue;
            if (TeamResources.Instance == null || TeamResources.Instance.CanAfford(t, item.costs))
                return item;
        }

        return null;
    }

    bool CategoryMatch(string a, string b)
    {
        string na = string.IsNullOrWhiteSpace(a) ? "" : a.Trim().ToLowerInvariant();
        string nb = string.IsNullOrWhiteSpace(b) ? "" : b.Trim().ToLowerInvariant();
        return na == nb;
    }
}

==============================
FILE: AIRebuildManager.cs
==============================

using UnityEngine;
using System.Collections.Generic;

public class AIRebuildManager : MonoBehaviour
{
    public int teamID;

    // Stores (building definition, rebuild position)
    private readonly Queue<(BuildItemDefinition, Vector3)> rebuildQueue
        = new Queue<(BuildItemDefinition, Vector3)>();

    /// <summary>
    /// Call this from your building destruction logic.
    /// Example:
    /// FindObjectOfType<AIRebuildManager>()?.NotifyBuildingDestroyed(teamID, item, position);
    /// </summary>
    public void NotifyBuildingDestroyed(int lostTeam, BuildItemDefinition item, Vector3 pos)
    {
        if (lostTeam != teamID)
            return;

        rebuildQueue.Enqueue((item, pos));
    }

    public void Tick()
    {
        if (rebuildQueue.Count == 0)
            return;

        var (item, pos) = rebuildQueue.Peek();

        // Check resources
        if (!TeamResources.Instance.CanAfford(teamID, item.costs))
            return;

        // Check placement
        if (!BuildPlacementManager.Instance.CanPlaceAt(pos))
            return;

        // Rebuild
        BuildPlacementManager.Instance.PlaceBuild(
            item,
            pos,
            Quaternion.identity,
            teamID
        );

        rebuildQueue.Dequeue();
    }
}

==============================
FILE: AIRepairManager.cs
==============================

using UnityEngine;

public class AIRepairManager : MonoBehaviour
{
    public int teamID;
    public float repairRange = 30f;
    public float repairAmount = 8f;
    public float repairInterval = 1f;

    float timer;

    public void Tick()
    {
        timer -= Time.deltaTime;
        if (timer > 0f) return;
        timer = repairInterval;

        RepairNearbyBuildings();
    }

    void RepairNearbyBuildings()
    {
        Attackable[] all = GameObject.FindObjectsOfType<Attackable>();

        foreach (var a in all)
        {
            if (a.teamID != teamID) continue;
            if (!a.canBeRepaired) continue;
            if (!a.IsDamaged) continue;

            if (Vector3.Distance(transform.position, a.transform.position) > repairRange)
                continue;

            a.Repair(repairAmount);
            return; // repair ONE per tick
        }
    }
}


==============================
FILE: AIResourceManager.cs
==============================

using UnityEngine;
using System.Collections.Generic;

public class AIResourceManager : MonoBehaviour
{
    [Header("Team Settings")]
    public int teamID;

    [Header("Resource Claiming")]
    public float claimRadius = 35f;

    // Internal list of nodes this AI has claimed
    private readonly List<ResourceNode> claimedNodes = new List<ResourceNode>();

    // Called by your AI tick system
    public void Tick()
    {
        ClaimNearbyNodes();
        DefendNodes();
    }

    // ---------------------------------------------------------
    // CLAIM NODES
    // ---------------------------------------------------------
    void ClaimNearbyNodes()
    {
        ResourceNode[] allNodes = GameObject.FindObjectsOfType<ResourceNode>();

        foreach (var node in allNodes)
        {
            if (node == null) continue;
            if (node.IsDepleted) continue;
            if (node.IsClaimedByOther(teamID)) continue;
            if (claimedNodes.Contains(node)) continue;

            float dist = Vector3.Distance(transform.position, node.transform.position);
            if (dist > claimRadius)
                continue;

            node.claimedByTeam = teamID;
            claimedNodes.Add(node);
        }
    }

    // ---------------------------------------------------------
    // DEFEND CLAIMED NODES
    // ---------------------------------------------------------
    void DefendNodes()
    {
        AIThreatDetector threatDetector = GetComponent<AIThreatDetector>();
        AIMilitary military = GetComponent<AIMilitary>();

        if (threatDetector == null || military == null)
            return;

        foreach (var node in claimedNodes)
        {
            if (node == null) continue;
            if (node.IsDepleted) continue;

            Attackable threat = threatDetector.DetectThreatNear(node.transform.position);
            if (threat != null)
            {
                military.DefendLocation(node.transform.position);
            }
        }
    }
}

==============================
FILE: AIThreatDetector.cs
==============================

using UnityEngine;

public class AIThreatDetector : MonoBehaviour
{
    public int teamID;
    public float threatRadius = 18f;

    public Attackable DetectThreatNear(Vector3 pos)
    {
        Attackable[] all = GameObject.FindObjectsOfType<Attackable>();

        foreach (var a in all)
        {
            if (!a.IsAlive) continue;
            if (a.teamID == teamID) continue;
            if (!DiplomacyManager.Instance.AreAtWar(teamID, a.teamID)) continue;

            if (Vector3.Distance(pos, a.transform.position) <= threatRadius)
                return a;
        }

        return null;
    }
}


==============================
FILE: BuildCellReservation.cs
==============================

// ============================================================================
// BuildCellReservation.cs
//
// PURPOSE:
// - Marks a BuildGridCell with special placement restrictions.
// - Used to prevent buildings from being placed in specific areas such as:
//      * Walkways
//      * Defensive borders
//      * Reserved terrain
//
// DEPENDENCIES:
// - BuildGridCell:
//      * This component is attached to the same GameObject as BuildGridCell.
// - BuildPlacementManager:
//      * Checks this component when respectCellReservations = true.
//      * Blocks placement if blockBuildingPlacement is true.
// - BuildGridManager:
//      * Does NOT directly use this, but grid cells may be preconfigured
//        with reservations depending on map generation.
// - AIBuilder / AIRebuildManager:
//      * Should respect reservations if using grid-based placement.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new reservation types (e.g., “ReservedForRoad”, “ReservedForFarm”),
//   extend this script or create a more flexible tagging system.
// - If you add terrain-based auto-reservations, ensure BuildGridManager assigns
//   this component during grid generation.
// - If you add building footprints larger than 1 cell, reservation logic must
//   be extended to check multiple cells.
// - If you add zoning (residential, industrial, military), integrate here.
//
// INSPECTOR REQUIREMENTS:
// - reservedForWalkway: optional metadata for designers.
// - reservedForBorderDefense: optional metadata for designers.
// - blockBuildingPlacement: if true, BuildPlacementManager will reject placement.
// ============================================================================

using UnityEngine;

public class BuildCellReservation : MonoBehaviour
{
    public bool reservedForWalkway = true;
    public bool reservedForBorderDefense = false;

    [Tooltip("If true, no buildings can be placed here.")]
    public bool blockBuildingPlacement = true;
}

==============================
FILE: BuildPlacementManager.cs
==============================

// =============================================================
// BuildPlacementManager.cs
//
// PURPOSE:
// - Handles ALL building placement logic (player + AI).
// - Supports grid-based and world-space placement.
// - Creates ConstructionSite objects or instantly places buildings.
//
// DEPENDENCIES:
// - BuildItemDefinition:
//      * Prefab, costs, offsets.
// - BuildGridCell:
//      * Grid-based placement.
// - BuildCellReservation:
//      * Blocks placement when reserved.
// - ConstructionSite:
//      * Created when useConstructionSites = true.
// - TeamStorageManager / TeamResources:
//      * Cost checks + resource spending.
// - Building / Unit / Civilian:
//      * teamID applied to placed objects.
// - ResourceStorageProvider / ResourceDropoff:
//      * teamID applied.
// - TeamVisual:
//      * Applies team colors.
// - Physics:
//      * Used for world-space collision checks.
//
// NOTES FOR FUTURE MAINTENANCE:
// - Add multi-cell footprints if needed.
// - Add rotation support.
// - Add terrain height adaptation.
// - Add blueprint cancellation tracking.
// - Add MaterialPropertyBlock for preview performance.
//
// IMPORTANT:
// - This script does NOT delete teams.
// - It ONLY deletes duplicate BuildPlacementManager components,
//   NOT Team GameObjects.
// =============================================================

using UnityEngine;

public class BuildPlacementManager : MonoBehaviour
{
    public static BuildPlacementManager Instance;

    [Header("Selected (Player)")]
    public BuildItemDefinition selectedItem;

    [Header("Construction")]
    public bool useConstructionSites = true;
    public GameObject constructionSitePrefab; // MUST have ConstructionSite component

    [Tooltip("If true, you can only place blueprints when you can afford the full cost right now.")]
    public bool requireAffordToPlace = true;

    [Tooltip("If true, reserves required resources from building storage when placing a construction site.")]
    public bool reserveResourcesForSites = true;

    [Header("Placement Rules")]
    [Tooltip("If true, blocks placement on cells with BuildCellReservation.blockBuildingPlacement.")]
    public bool respectCellReservations = true;

    [Header("Preview (Optional)")]
    public bool showPreview = false;
    public Material previewMaterial;
    [Range(0.05f, 1f)] public float previewAlpha = 0.35f;

    private GameObject previewObj;

    // DEPENDENCIES:
    // - BuildItemDefinition: uses prefab, costs, yOffset
    // - ConstructionSite: must implement Init(cell, teamID, item, reserveResources)
    // - TeamResources / TeamStorageManager: used for cost checks
    // - BuildGridCell: grid-based placement for player/AI grid builds

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void SetSelected(BuildItemDefinition item)
    {
        selectedItem = item;
        ClearPreview();
        Debug.Log($"[BuildPlacementManager] Selected: {(item != null ? item.displayName : "None")}");
    }

    public bool TryPlace(BuildGridCell cell)
    {
        if (selectedItem == null) return false;
        return TryPlace(cell, selectedItem);
    }

    public bool CanPlaceAt(Vector3 pos)
    {
        return !Physics.CheckSphere(pos, 1.5f);
    }

    // ---------- GRID-BASED PLACEMENT (PLAYER / TEAM AIBuild) ----------

    public bool TryPlace(BuildGridCell cell, BuildItemDefinition item)
    {
        if (cell == null || item == null) return false;
        if (cell.isOccupied) return false;

        if (respectCellReservations)
        {
            var res = cell.GetComponent<BuildCellReservation>();
            if (res != null && res.blockBuildingPlacement)
                return false;
        }

        if (item.prefab == null)
        {
            Debug.LogWarning("[BuildPlacementManager] Build item has no prefab assigned.");
            return false;
        }

        // Always enforce "deposited in buildings" if storage manager exists
        if (requireAffordToPlace)
        {
            bool canAfford = false;

            if (TeamStorageManager.Instance != null)
                canAfford = TeamStorageManager.Instance.CanAffordAvailable(cell.teamID, item.costs);
            else if (TeamResources.Instance != null)
                canAfford = TeamResources.Instance.CanAfford(cell.teamID, item.costs);

            if (!canAfford)
                return false;
        }

        Vector3 pos = cell.worldCenter
                      + new Vector3(item.placementOffset.x, item.yOffset + item.placementOffset.y, item.placementOffset.z);
        Quaternion rot = Quaternion.identity;

        GameObject placed;

        if (useConstructionSites && constructionSitePrefab != null)
        {
            placed = Instantiate(constructionSitePrefab, pos, rot);

            EnsureBuildItemInstance(placed, item);

            var site = placed.GetComponent<ConstructionSite>();
            if (site == null)
            {
                Debug.LogWarning("[BuildPlacementManager] constructionSitePrefab is missing ConstructionSite component.");
                Destroy(placed);
                return false;
            }

            site.Init(cell, cell.teamID, item, reserveResourcesForSites);

            if (!site.InitOK)
            {
                Destroy(placed);
                return false;
            }

            var tv = placed.GetComponent<TeamVisual>();
            if (tv != null)
            {
                tv.teamID = cell.teamID;
                tv.kind = VisualKind.Building;
                tv.Apply();
            }
        }
        else
        {
            // Instant placement (spend immediately from building storage)
            if (TeamResources.Instance != null)
            {
                if (!TeamResources.Instance.CanAfford(cell.teamID, item.costs))
                    return false;

                if (!TeamResources.Instance.Spend(cell.teamID, item.costs))
                    return false;
            }

            placed = Instantiate(item.prefab, pos, rot);

            EnsureBuildItemInstance(placed, item);
            ApplyTeamToPlacedObject(placed, cell.teamID);
        }

        cell.isOccupied = true;
        cell.placedObject = placed;

        return true;
    }

    // ---------- WORLD-SPACE PLACEMENT (AIBuilder / AIRebuildManager) ----------

    public bool PlaceBuild(BuildItemDefinition item, Vector3 pos, Quaternion rot, int teamID)
    {
        if (item == null || item.prefab == null)
            return false;

        if (!CanPlaceAt(pos))
            return false;

        // Cost check + spend
        if (TeamResources.Instance != null)
        {
            if (!TeamResources.Instance.CanAfford(teamID, item.costs))
                return false;

            if (!TeamResources.Instance.Spend(teamID, item.costs))
                return false;
        }

        Vector3 finalPos = pos
                           + new Vector3(item.placementOffset.x, item.yOffset + item.placementOffset.y, item.placementOffset.z);

        GameObject placed = Instantiate(item.prefab, finalPos, rot);

        EnsureBuildItemInstance(placed, item);
        ApplyTeamToPlacedObject(placed, teamID);

        return true;
    }

    void EnsureBuildItemInstance(GameObject go, BuildItemDefinition item)
    {
        if (go == null || item == null) return;

        BuildItemInstance bii = go.GetComponent<BuildItemInstance>();
        if (bii == null) bii = go.AddComponent<BuildItemInstance>();
        bii.itemId = item.name;
    }

    void ApplyTeamToPlacedObject(GameObject placed, int teamID)
    {
        if (placed == null) return;

        Building building = placed.GetComponent<Building>();
        if (building != null) building.teamID = teamID;

        Civilian civ = placed.GetComponent<Civilian>();
        if (civ != null) civ.teamID = teamID;

        Unit unit = placed.GetComponent<Unit>();
        if (unit != null) unit.teamID = teamID;

        var sp = placed.GetComponent<ResourceStorageProvider>();
        if (sp != null) sp.teamID = teamID;

        var drop = placed.GetComponent<ResourceDropoff>();
        if (drop != null) drop.teamID = teamID;

        var storage = placed.GetComponent<ResourceStorageContainer>();
        if (storage != null) storage.teamID = teamID;

        TeamVisual tv = placed.GetComponent<TeamVisual>();
        if (tv != null)
        {
            tv.teamID = teamID;
            tv.kind = (building != null) ? VisualKind.Building : VisualKind.Unit;
            tv.Apply();
        }
    }

    // ---------- Optional Preview ----------

    public void ShowPreviewAt(BuildGridCell cell)
    {
        if (!showPreview) return;
        if (cell == null) return;
        if (selectedItem == null) return;
        if (previewMaterial == null) return;

        if (respectCellReservations)
        {
            var res = cell.GetComponent<BuildCellReservation>();
            if (res != null && res.blockBuildingPlacement)
            {
                ClearPreview();
                return;
            }
        }

        Vector3 pos = cell.worldCenter
                      + new Vector3(selectedItem.placementOffset.x,
                                    selectedItem.yOffset + selectedItem.placementOffset.y,
                                    selectedItem.placementOffset.z);

        if (previewObj == null)
        {
            previewObj = Instantiate(selectedItem.prefab);
            previewObj.name = "BuildPreview";
            DisableGameplayComponents(previewObj);
            ApplyPreviewMaterial(previewObj);
        }

        previewObj.transform.SetPositionAndRotation(pos, Quaternion.identity);
        previewObj.SetActive(true);
    }

    public void ClearPreview()
    {
        if (previewObj != null)
            previewObj.SetActive(false);
    }

    void DisableGameplayComponents(GameObject go)
    {
        foreach (var c in go.GetComponentsInChildren<Collider>(true))
            c.enabled = false;

        foreach (var mb in go.GetComponentsInChildren<MonoBehaviour>(true))
        {
            if (mb == null) continue;
            if (mb is BuildPlacementManager) continue;
            mb.enabled = false;
        }
    }

    void ApplyPreviewMaterial(GameObject go)
    {
        var renderers = go.GetComponentsInChildren<Renderer>(true);
        foreach (var r in renderers)
        {
            if (r == null) continue;

            Material m = new Material(previewMaterial);
            Color c = m.color;
            c.a = previewAlpha;
            m.color = c;

            r.material = m;
        }
    }
}

==============================
FILE: JobManager.cs
==============================

// =============================================================
// JobManager.cs
//
// DEPENDENCIES:
// - Civilian: registered/unregistered here, roles tracked
// - CivilianRole: enum of roles (Gatherer, Builder, Hauler, Idle)
// - ConstructionSite: used for CountBuildersOnSite + GetActiveConstructionSiteCount
// - TaskBoardUI: calls GetRoleCounts() and GetActiveConstructionSiteCount()
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new roles, CivilianRole and any UI must be updated.
// - Keep civilians list in sync with Civilian.OnEnable/OnDisable.
// =============================================================

using UnityEngine;
using System.Collections.Generic;

public class JobManager : MonoBehaviour
{
    public static JobManager Instance;

    private readonly List<Civilian> civilians = new List<Civilian>();

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }
        Instance = this;
    }

    public void RegisterCivilian(Civilian civ)
    {
        if (civ == null) return;
        if (!civilians.Contains(civ))
            civilians.Add(civ);
    }

    public void UnregisterCivilian(Civilian civ)
    {
        if (civ == null) return;
        civilians.Remove(civ);
    }

    public bool IsCivilianAssigned(Civilian civ)
    {
        return civ != null && civ.HasJob;
    }

    public int CountBuildersOnSite(ConstructionSite site)
    {
        int count = 0;
        for (int i = 0; i < civilians.Count; i++)
        {
            var civ = civilians[i];
            if (civ == null) continue;
            if (civ.CurrentAssignedSite == site)
                count++;
        }
        return count;
    }

    public Dictionary<CivilianRole, int> GetRoleCounts(int teamID)
    {
        var result = new Dictionary<CivilianRole, int>();

        foreach (CivilianRole r in System.Enum.GetValues(typeof(CivilianRole)))
            result[r] = 0;

        for (int i = 0; i < civilians.Count; i++)
        {
            var civ = civilians[i];
            if (civ == null) continue;
            if (civ.teamID != teamID) continue;

            if (!result.ContainsKey(civ.role))
                result[civ.role] = 0;

            result[civ.role]++;
        }

        return result;
    }

    public int GetActiveConstructionSiteCount(int teamID)
    {
        int count = 0;
        var sites = GameObject.FindObjectsOfType<ConstructionSite>();
        for (int i = 0; i < sites.Length; i++)
        {
            var s = sites[i];
            if (s == null) continue;
            if (s.teamID != teamID) continue;
            if (s.IsComplete) continue;
            count++;
        }
        return count;
    }
}

==============================
FILE: IAttackable.cs
==============================

using UnityEngine;
public interface IAttackable
{
    int TeamID { get; }
    bool IsAlive { get; }
    Transform AimPoint { get; }
    void TakeDamage(float amount);
}


==============================
FILE: ICommandable.cs
==============================

using UnityEngine;

public interface ICommandable
{
    void IssueMove(Vector3 worldPos);
}


==============================
FILE: IHasHealth.cs
==============================

public interface IHasHealth
{
    float CurrentHealth { get; }
    float MaxHealth { get; }
}


==============================
FILE: ITargetable.cs
==============================

public interface ITargetable
{
    int TeamID { get; }
    bool IsAlive { get; }
    void TakeDamage(float damage);
}


==============================
FILE: ProjectilePool.cs
==============================

// =============================================================
// ProjectilePool.cs
//
// PURPOSE:
// - Unified projectile pooling for all weapons.
// - Replaces TurretProjectilePool.
//
// DEPENDENCIES:
// - Projectile:
//      * Must have a prefabKey reference for pooling.
//
// NOTES FOR FUTURE MAINTENANCE:
// - Supports multiple projectile types.
// - If you add explosive projectiles, they can still use this pool.
// =============================================================

using System.Collections.Generic;
using UnityEngine;

public class ProjectilePool : MonoBehaviour
{
    public static ProjectilePool Instance;

    private readonly Dictionary<Projectile, Stack<Projectile>> pools =
        new Dictionary<Projectile, Stack<Projectile>>();

    void Awake()
    {
        Instance = this;
    }

    public Projectile Spawn(Projectile prefab, Vector3 pos, Quaternion rot)
    {
        if (!pools.TryGetValue(prefab, out var stack))
        {
            stack = new Stack<Projectile>();
            pools[prefab] = stack;
        }

        Projectile obj = (stack.Count > 0) ? stack.Pop() : Instantiate(prefab);
        obj.prefabKey = prefab;
        obj.transform.SetPositionAndRotation(pos, rot);
        obj.gameObject.SetActive(true);
        return obj;
    }

    public void Despawn(Projectile obj)
    {
        if (obj == null) return;

        obj.gameObject.SetActive(false);

        if (obj.prefabKey != null)
        {
            if (!pools.TryGetValue(obj.prefabKey, out var stack))
            {
                stack = new Stack<Projectile>();
                pools[obj.prefabKey] = stack;
            }
            stack.Push(obj);
        }
        else
        {
            Destroy(obj.gameObject);
        }
    }
}

==============================
FILE: TurretProjectilePool.cs
==============================

// =============================================================
// TurretProjectilePool.cs
//
// DEPENDENCIES:
// - TurretProjectile:
//      * Projectiles spawned and despawned by this pool.
// - Turret / any weapon system using TurretProjectile:
//      * Should call Spawn() and Despawn() instead of Instantiate/Destroy.
//
// NOTES FOR FUTURE MAINTENANCE:
// - This is a generic pool keyed by prefab.
// - If you add different turret projectile types, they can all share this pool.
// - Make sure there is exactly one TurretProjectilePool in the scene.
// =============================================================

using System.Collections.Generic;
using UnityEngine;

public class TurretProjectilePool : MonoBehaviour
{
    public static TurretProjectilePool Instance;

    private readonly Dictionary<TurretProjectile, Stack<TurretProjectile>> pools =
        new Dictionary<TurretProjectile, Stack<TurretProjectile>>();

    void Awake()
    {
        Instance = this;
    }

    public TurretProjectile Spawn(TurretProjectile prefab, Vector3 pos, Quaternion rot)
    {
        if (!pools.TryGetValue(prefab, out var stack))
        {
            stack = new Stack<TurretProjectile>();
            pools[prefab] = stack;
        }

        TurretProjectile obj = (stack.Count > 0) ? stack.Pop() : Instantiate(prefab);
        obj.transform.SetPositionAndRotation(pos, rot);
        obj.gameObject.SetActive(true);

        obj.prefabKey = prefab;

        return obj;
    }

    public void Despawn(TurretProjectile obj)
    {
        if (obj == null) return;

        obj.gameObject.SetActive(false);

        if (obj.prefabKey != null)
        {
            if (!pools.TryGetValue(obj.prefabKey, out var stack))
            {
                stack = new Stack<TurretProjectile>();
                pools[obj.prefabKey] = stack;
            }
            stack.Push(obj);
        }
        else
        {
            Destroy(obj.gameObject);
        }
    }
}

==============================
FILE: WeaponComponent.cs
==============================

// =============================================================
// WeaponComponent.cs
//
// PURPOSE:
// - Shared firing logic for Units, Turrets, and any future ranged entity.
// - Handles projectile pooling, muzzle FX, fire cooldowns.
//
// DEPENDENCIES:
// - ProjectilePool:
//      * Spawns/despawns projectiles.
// - Projectile:
//      * Unified projectile logic.
// - Attackable:
//      * Target interface for damage application.
// - UnitCombatController:
//      * Calls FireAtTarget() when ready to shoot.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add different weapon types (burst, beam, AoE), extend this class.
// - If you add ammo or overheating, add checks before firing.
// - If you add sound FX, trigger them here.
// =============================================================

using UnityEngine;

public class WeaponComponent : MonoBehaviour
{
    [Header("Weapon Stats")]
    public float damage = 10f;
    public float fireCooldown = 0.75f;
    public float range = 8f;

    [Header("Projectile")]
    public Projectile projectilePrefab;
    public Transform muzzle;

    [Header("FX")]
    public GameObject muzzleFlashFX;

    private float fireTimer;

    public bool CanFire => fireTimer <= 0f;

    void Update()
    {
        fireTimer -= Time.deltaTime;
    }

    public void FireAtTarget(Attackable target, int teamID)
    {
        if (!CanFire || target == null || !target.IsAlive)
            return;

        fireTimer = fireCooldown;

        if (muzzleFlashFX != null)
            Instantiate(muzzleFlashFX, muzzle.position, muzzle.rotation);

        Projectile proj = ProjectilePool.Instance.Spawn(projectilePrefab, muzzle.position, muzzle.rotation);
        proj.Init(target, damage, teamID);
    }
}

==============================
FILE: CraftingSystem.cs
==============================

using UnityEngine;

public class CraftingSystem : MonoBehaviour
{
    public static CraftingSystem Instance;

    void Awake()
    {
        Instance = this;
    }

    // ---------------------------------------------------------
    // DEPENDENCIES:
    // - TeamResources: must implement SpendResource(teamID, type, amount)
    // - TeamStorageManager: used for GetTotalStored(teamID, type)
    // - TeamInventory: must implement AddTool(teamID, item, amount)
    // - ToolItem: must contain craftCost[]
    // ---------------------------------------------------------

    public bool CraftTool(int teamID, ToolItem item, int amount = 1)
    {
        if (item == null || amount <= 0) return false;
        if (TeamResources.Instance == null || TeamInventory.Instance == null) return false;

        // Check resource availability
        if (item.craftCost != null)
        {
            for (int i = 0; i < item.craftCost.Length; i++)
            {
                int need = item.craftCost[i].amount * amount;

                // NEW: use TeamStorageManager for stored resources
                int stored = TeamStorageManager.Instance.GetTotalStored(teamID, item.craftCost[i].type);
                if (stored < need)
                    return false;
            }

            // Spend resources
            for (int i = 0; i < item.craftCost.Length; i++)
            {
                int need = item.craftCost[i].amount * amount;
                TeamResources.Instance.SpendResource(teamID, item.craftCost[i].type, need);
            }
        }

        TeamInventory.Instance.AddTool(teamID, item, amount);
        return true;
    }
}

==============================
FILE: ResourceRegistry.cs
==============================

using System;
using System.Collections.Generic;
using UnityEngine;

public class ResourceRegistry : MonoBehaviour
{
    public static ResourceRegistry Instance;

    private readonly Dictionary<ResourceType, List<ResourceNode>> nodesByType = new Dictionary<ResourceType, List<ResourceNode>>();

    void Awake()
    {
        Instance = this;

        // Pre-create lists for all enum values so lookups are cheap
        foreach (ResourceType t in Enum.GetValues(typeof(ResourceType)))
            nodesByType[t] = new List<ResourceNode>();
    }

    public void Register(ResourceNode node)
    {
        if (node == null) return;
        if (!nodesByType.TryGetValue(node.type, out var list))
        {
            list = new List<ResourceNode>();
            nodesByType[node.type] = list;
        }
        if (!list.Contains(node)) list.Add(node);
    }

    public void Unregister(ResourceNode node)
    {
        if (node == null) return;
        if (nodesByType.TryGetValue(node.type, out var list))
            list.Remove(node);
    }

    public List<ResourceNode> GetNodes(ResourceType type)
    {
        if (!nodesByType.TryGetValue(type, out var list))
        {
            list = new List<ResourceNode>();
            nodesByType[type] = list;
        }
        return list;
    }
}


==============================
FILE: BuildGridCell.cs
==============================

// ============================================================================
// BuildGridCell.cs
//
// PURPOSE:
// - Represents a single tile in the build grid.
// - Stores team ownership, world position, occupancy state, and placed object.
// - Handles click interaction for building placement.
//
// DEPENDENCIES:
// - BuildGridManager:
//      * Calls Init() to assign teamID, coordinates, and worldCenter.
//      * Calls OnCellClicked() when this cell is clicked.
// - BuildPlacementManager:
//      * Attempts to place buildings when a cell is clicked.
// - BuildCellReservation (optional):
//      * May be attached to the same GameObject to restrict placement.
// - BuildMenuUI:
//      * Syncs grid visibility with build menu visibility.
// - ConstructionSite / Building:
//      * When a building is placed, gridCell.placedObject is assigned.
// - EventSystem:
//      * Used to prevent clicks through UI.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add multi-cell buildings, this class must support footprint metadata.
// - If you add terrain alignment, worldCenter should be adjusted to terrain height.
// - If you add drag-to-place or area selection, OnMouseDown may need expansion.
// - If you add fog-of-war, visibility logic should be integrated here.
// - If you add AI building logic, ensure AI respects teamID and occupancy.
//
// INSPECTOR REQUIREMENTS:
// - None; this component is created dynamically by BuildGridManager.
// ============================================================================

using UnityEngine;
using UnityEngine.EventSystems;

public class BuildGridCell : MonoBehaviour
{
    [HideInInspector] public int teamID;
    [HideInInspector] public Vector2Int gridCoord;
    [HideInInspector] public Vector3 worldCenter;

    private BuildGridManager manager;
    public bool isOccupied;
    public GameObject placedObject;

    public void Init(BuildGridManager mgr, int t, Vector2Int coord, Vector3 center)
    {
        manager = mgr;
        teamID = t;
        gridCoord = coord;
        worldCenter = center;
    }

    void OnMouseDown()
    {
        if (EventSystem.current != null && EventSystem.current.IsPointerOverGameObject())
            return;

        if (manager != null)
            manager.OnCellClicked(this);
    }
}

==============================
FILE: BuildGridManager.cs
==============================

// ============================================================================
// BuildGridManager.cs
//
// PURPOSE:
// - Generates and manages the build grid around each Headquarters.
// - Controls visibility of the grid for the player.
// - Handles cell selection, highlighting, and click routing.
// - Ensures non-player grids are hidden and unclickable.
// - Acts as the central controller for grid-based building placement.
//
// DEPENDENCIES:
// - BuildGridCell:
//      * Created for each grid tile.
//      * Stores teamID, worldCenter, occupancy, placedObject.
// - BuildCellReservation (optional):
//      * Attached to cells to restrict placement.
// - BuildPlacementManager:
//      * Called when a cell is clicked to attempt building placement.
// - BuildMenuUI:
//      * Syncs grid visibility with build menu visibility.
// - Headquarters:
//      * Grid is generated around each HQ.
//      * teamID is read from Building component on HQ.
// - Building:
//      * Used to determine team ownership of HQs.
// - TeamVisual (optional):
//      * Not directly used here, but placed buildings rely on teamID set by this system.
// - EventSystem:
//      * Used indirectly via BuildGridCell to prevent UI click-through.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add multi-cell buildings, grid generation must support footprint checks.
// - If you add terrain height variation, adjust cell Y positions to match terrain.
// - If you add fog-of-war, grid visibility should be tied to player vision.
// - If you add AI building logic, ensure AI respects teamID and occupancy rules.
// - If you add rotation-based building placement, highlight should reflect orientation.
// - If you add snapping to roads or zones, integrate reservation logic here.
//
// INSPECTOR REQUIREMENTS:
// - cellSize: spacing between grid tiles.
// - halfExtent: grid radius around HQ.
// - cellMaterial: default tile material.
// - selectedMaterial: highlight material.
// - buildMenuUI: optional; used to sync visibility.
// ============================================================================

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BuildGridManager : MonoBehaviour
{
    [Header("Player")]
    public int playerTeamID = 0;

    [Header("Toggle")]
    public KeyCode toggleKey = KeyCode.B;

    [Header("Grid Settings")]
    public float cellSize = 2f;
    public int halfExtent = 6;
    public float yOffset = 0.03f;

    [Header("Visuals")]
    public Material cellMaterial;          // Mat_GridCell (blue)
    public Material selectedMaterial;      // Mat_GridCell_Selected (optional)

    [Header("UI")]
    public BuildMenuUI buildMenuUI;

    private bool isVisible = false;

    private readonly List<GameObject> allCells = new List<GameObject>();
    private BuildGridCell selectedCell;

    void Start()
    {
        StartCoroutine(DelayedBuild());
    }

    IEnumerator DelayedBuild()
    {
        yield return null; // wait 1 frame so HQs exist
        BuildAllGrids();

        SetPlayerGridVisible(false);

        if (buildMenuUI != null)
            buildMenuUI.SetVisible(false);
    }

    void Update()
    {
        if (Input.GetKeyDown(toggleKey))
        {
            if (allCells.Count == 0)
                BuildAllGrids();

            isVisible = !isVisible;
            SetPlayerGridVisible(isVisible);

            if (buildMenuUI != null)
                buildMenuUI.SetVisible(isVisible);
        }
    }

    public void BuildAllGrids()
    {
        // Destroy old cells
        for (int i = 0; i < allCells.Count; i++)
            if (allCells[i] != null) Destroy(allCells[i]);

        allCells.Clear();
        selectedCell = null;

        Headquarters[] hqs = FindObjectsOfType<Headquarters>();
        Debug.Log($"[BuildGridManager] Found HQs: {hqs.Length}");

        foreach (var hq in hqs)
        {
            int teamID = 0;

            Building b = hq.GetComponent<Building>();
            if (b != null) teamID = b.teamID;

            BuildGridAroundHQ(hq.transform.position, teamID);
        }

        EnforceNonPlayerHiddenAndUnclickable();
    }

    void BuildGridAroundHQ(Vector3 hqPos, int teamID)
    {
        Vector3 origin = new Vector3(hqPos.x, yOffset, hqPos.z);

        origin.x = Mathf.Round(origin.x / cellSize) * cellSize;
        origin.z = Mathf.Round(origin.z / cellSize) * cellSize;

        GameObject parent = new GameObject($"BuildGrid_Team{teamID}");
        parent.transform.SetParent(transform, false);

        for (int gx = -halfExtent; gx <= halfExtent; gx++)
        {
            for (int gz = -halfExtent; gz <= halfExtent; gz++)
            {
                Vector3 center = origin + new Vector3(gx * cellSize, 0f, gz * cellSize);

                GameObject cellObj = GameObject.CreatePrimitive(PrimitiveType.Quad);
                cellObj.name = $"Cell_{teamID}_{gx}_{gz}";
                cellObj.transform.SetParent(parent.transform, false);

                cellObj.transform.position = center;
                cellObj.transform.rotation = Quaternion.Euler(90f, 0f, 0f);
                cellObj.transform.localScale = Vector3.one * (cellSize * 0.95f);

                Collider col = cellObj.GetComponent<Collider>();
                if (col == null) cellObj.AddComponent<MeshCollider>();

                Renderer r = cellObj.GetComponent<Renderer>();
                if (r != null && cellMaterial != null)
                    r.sharedMaterial = cellMaterial;

                BuildGridCell cell = cellObj.AddComponent<BuildGridCell>();
                cell.Init(this, teamID, new Vector2Int(gx, gz), center);

                allCells.Add(cellObj);
            }
        }
    }

    void EnforceNonPlayerHiddenAndUnclickable()
    {
        for (int i = 0; i < allCells.Count; i++)
        {
            var go = allCells[i];
            if (go == null) continue;

            var cell = go.GetComponent<BuildGridCell>();
            if (cell == null) continue;

            if (cell.teamID != playerTeamID)
            {
                var r = go.GetComponent<Renderer>();
                if (r != null) r.enabled = false;

                var c = go.GetComponent<Collider>();
                if (c != null) c.enabled = false;
            }
        }
    }

    void SetPlayerGridVisible(bool visible)
    {
        for (int i = 0; i < allCells.Count; i++)
        {
            var go = allCells[i];
            if (go == null) continue;

            var cell = go.GetComponent<BuildGridCell>();
            if (cell == null) continue;

            if (cell.teamID == playerTeamID)
            {
                ApplyCellVisibility(cell, visible);
            }
            else
            {
                var r = go.GetComponent<Renderer>();
                if (r != null) r.enabled = false;

                var c = go.GetComponent<Collider>();
                if (c != null) c.enabled = false;
            }
        }

        if (!visible && selectedCell != null)
        {
            SetCellMaterial(selectedCell, cellMaterial);
            selectedCell = null;
        }
    }

    void ApplyCellVisibility(BuildGridCell cell, bool gridVisible)
    {
        if (cell == null) return;

        bool showTile = gridVisible && !cell.isOccupied;

        var r = cell.GetComponent<Renderer>();
        if (r != null) r.enabled = showTile;

        var c = cell.GetComponent<Collider>();
        if (c != null) c.enabled = showTile;
    }

    public void OnCellClicked(BuildGridCell cell)
    {
        if (!isVisible) return;
        if (cell == null) return;

        if (cell.teamID != playerTeamID) return;

        if (cell.isOccupied) return;

        if (BuildPlacementManager.Instance != null &&
            BuildPlacementManager.Instance.selectedItem != null)
        {
            if (BuildPlacementManager.Instance.TryPlace(cell))
            {
                ApplyCellVisibility(cell, isVisible);

                if (selectedCell != null) SetCellMaterial(selectedCell, cellMaterial);
                selectedCell = null;
                return;
            }
        }

        if (selectedCell != null && selectedCell != cell)
            SetCellMaterial(selectedCell, cellMaterial);

        selectedCell = cell;

        if (selectedMaterial != null)
            SetCellMaterial(selectedCell, selectedMaterial);
    }

    void SetCellMaterial(BuildGridCell cell, Material mat)
    {
        if (cell == null || mat == null) return;
        var r = cell.GetComponent<Renderer>();
        if (r != null) r.sharedMaterial = mat;
    }
}

==============================
FILE: BuildMenuUI.cs
==============================

// ============================================================================
// BuildMenuUI.cs
//
// PURPOSE:
// - Provides the entire in-game Build Menu UI.
// - Displays categories, items, costs, search, and affordability.
// - Syncs visibility with the build grid.
// - Allows the player to select a BuildItemDefinition for placement.
//
// DEPENDENCIES:
// - BuildItemDefinition:
//      * Provides displayName, icon, costs, category.
// - BuildCatalog (optional):
//      * If autoDiscover is off, categories[] may be manually populated.
// - BuildPlacementManager:
//      * Receives SetSelected(item) when the player clicks a build button.
//      * Clears selection when menu closes.
// - BuildGridManager (indirect):
//      * Visibility sync via TrySyncGrid().
// - TeamStorageManager / TeamResources:
//      * Used to check affordability (CanAffordAvailable / CanAfford).
// - IMGUIInputBlocker:
//      * Prevents clicks through UI.
// - Resources folder:
//      * Auto-discovery loads BuildItemDefinition assets from Resources/BuildItems.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add a new UI system (Unity UI Toolkit, uGUI), this script may be replaced.
// - If you add hotkeys for categories or items, integrate them in Update().
// - If you add multi-page categories, extend the tab system.
// - If you add building previews in UI, integrate with BuildPlacementManager.ShowPreviewAt().
// - If you add tech-tree requirements, filter items based on unlock state.
// - If you add AI debugging tools, expose category and item lists.
//
// INSPECTOR REQUIREMENTS:
// - playerTeamID: used for affordability checks.
// - toggleKey: key to open/close the build menu.
// - resourcesPath: folder for auto-discovery.
// - categories: used when autoDiscover = false.
// - showCosts / showAffordability: UI toggles.
// - trySyncBuildGridVisibility: syncs grid visibility with menu.
// ============================================================================

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using UnityEngine;

public class BuildMenuUI : MonoBehaviour
{
    [Serializable]
    public class BuildCategory
    {
        public string name = "Category";
        public Texture2D icon;
        public BuildItemDefinition[] items;
    }

    [Header("Player")]
    public int playerTeamID = 0;

    [Header("Toggle")]
    public bool show = false;
    public KeyCode toggleKey = KeyCode.B;

    [Header("Panel Layout (Top Right)")]
    public int panelWidth = 460;
    public int panelHeight = 420;
    public int marginRight = 12;
    public int marginTop = 12;

    [Header("Catalog Source")]
    public bool autoDiscover = true;
    public string resourcesPath = "BuildItems";
    public bool useManualCatalogWhenAutoDiscoverOff = true;

    [Header("Manual Catalog (optional)")]
    public BuildCategory[] categories;

    [Header("Optional Sync With Grid")]
    public bool trySyncBuildGridVisibility = true;

    [Header("UI")]
    public bool showCosts = true;
    public bool showAffordability = true;

    private int selectedCategoryIndex = 0;
    private Vector2 scroll;
    private string search = "";
    private readonly StringBuilder sb = new StringBuilder(256);

    private readonly StringBuilder costSb = new StringBuilder(128);

    public bool IsVisible => show;

    public void SetVisible(bool visible)
    {
        show = visible;

        if (!show)
        {
            if (BuildPlacementManager.Instance != null)
                BuildPlacementManager.Instance.SetSelected(null);
        }

        if (trySyncBuildGridVisibility)
            TrySyncGrid(show);
    }

    public void ToggleVisible() => SetVisible(!show);

    public void RebuildCatalog()
    {
        if (autoDiscover)
        {
            categories = DiscoverFromResources(resourcesPath);
            selectedCategoryIndex = Mathf.Clamp(selectedCategoryIndex, 0, Mathf.Max(0, categories.Length - 1));
            scroll = Vector2.zero;
        }
    }

    void Start()
    {
        if (autoDiscover) categories = DiscoverFromResources(resourcesPath);
        else if (!useManualCatalogWhenAutoDiscoverOff) categories = new BuildCategory[0];

        selectedCategoryIndex = (categories != null && categories.Length > 0)
            ? Mathf.Clamp(selectedCategoryIndex, 0, categories.Length - 1)
            : 0;

        if (trySyncBuildGridVisibility)
            TrySyncGrid(show);
    }

    void Update()
    {
        if (Input.GetKeyDown(toggleKey))
            ToggleVisible();
    }

    void OnGUI()
    {
        if (!show) return;

        float left = Screen.width - panelWidth - marginRight;
        float top = marginTop;

        Rect panelRect = new Rect(left, top, panelWidth, panelHeight);
        IMGUIInputBlocker.Register(panelRect);

        GUI.Box(panelRect, "BUILD MENU");

        float x = panelRect.x + 10;
        float y = panelRect.y + 24;

        if (categories == null || categories.Length == 0)
        {
            GUI.Label(new Rect(x, y, panelWidth - 20, 20), "No build items found.");
            y += 20;

            if (autoDiscover)
            {
                GUI.Label(new Rect(x, y, panelWidth - 20, 20), $"Resources path: \"{resourcesPath}\"");
                y += 20;
                if (GUI.Button(new Rect(x, y, 160, 22), "Rebuild Catalog"))
                    RebuildCatalog();
            }
            return;
        }

        GUI.Label(new Rect(x, y, 60, 20), "Search:");
        search = GUI.TextField(new Rect(x + 62, y, panelWidth - 20 - 62, 20), search ?? "");
        y += 26;

        float tabH = 28f;
        float tabW = Mathf.Max(90f, (panelWidth - 20) / Mathf.Max(1, Mathf.Min(categories.Length, 4)));
        int maxTabsPerRow = Mathf.Max(1, Mathf.FloorToInt((panelWidth - 20) / tabW));

        int tabIndex = 0;
        while (tabIndex < categories.Length)
        {
            int rowCount = Mathf.Min(maxTabsPerRow, categories.Length - tabIndex);

            for (int i = 0; i < rowCount; i++)
            {
                int idx = tabIndex + i;
                Rect r = new Rect(x + i * tabW, y, tabW - 6, tabH);
                bool isSel = (idx == selectedCategoryIndex);

                bool prev = GUI.enabled;
                GUI.enabled = !isSel;

                string label = categories[idx] != null ? categories[idx].name : "Null";
                if (GUI.Button(r, label))
                {
                    selectedCategoryIndex = idx;
                    scroll = Vector2.zero;
                }

                GUI.enabled = prev;
            }

            y += tabH + 6;
            tabIndex += rowCount;
        }

        selectedCategoryIndex = Mathf.Clamp(selectedCategoryIndex, 0, categories.Length - 1);
        BuildCategory cat = categories[selectedCategoryIndex];

        GUI.Label(new Rect(x, y, panelWidth - 20, 18), $"Category: {cat.name}");
        y += 20;

        Rect listRect = new Rect(x, y, panelWidth - 20, panelRect.yMax - y - 10);
        GUI.Box(listRect, "");

        float innerX = listRect.x + 8;
        float innerY = listRect.y + 8;
        float innerW = listRect.width - 16;
        float innerH = listRect.height - 16;

        Rect viewRect = new Rect(0, 0, innerW - 18, Mathf.Max(innerH, 800));
        scroll = GUI.BeginScrollView(new Rect(innerX, innerY, innerW, innerH), scroll, viewRect);

        float iy = 0f;
        int drawn = 0;

        BuildItemDefinition[] items = (cat != null) ? cat.items : null;
        if (items == null || items.Length == 0)
        {
            GUI.Label(new Rect(0, iy, innerW - 18, 18), "No items in this category.");
            iy += 20;
        }
        else
        {
            for (int i = 0; i < items.Length; i++)
            {
                BuildItemDefinition item = items[i];
                if (item == null) continue;

                if (!string.IsNullOrEmpty(search))
                {
                    string dn = item.displayName ?? item.name;
                    if (dn == null) dn = "";
                    if (dn.IndexOf(search, StringComparison.OrdinalIgnoreCase) < 0)
                        continue;
                }

                bool canAfford = true;
                if (showAffordability)
                {
                    if (TeamStorageManager.Instance != null)
                        canAfford = TeamStorageManager.Instance.CanAffordAvailable(playerTeamID, item.costs);
                    else if (TeamResources.Instance != null)
                        canAfford = TeamResources.Instance.CanAfford(playerTeamID, item.costs);
                }

                string title = item.displayName;
                if (string.IsNullOrEmpty(title)) title = item.name;

                sb.Length = 0;
                sb.Append(title);

                if (showCosts)
                {
                    sb.Append("  ");
                    sb.Append(CostString(item.costs));
                }

                if (showAffordability && !canAfford)
                    sb.Append("  (Need deposited resources)");

                float rowH = 34f;
                Rect btn = new Rect(0, iy, innerW - 18, rowH);

                bool prev = GUI.enabled;
                GUI.enabled = canAfford;

                bool clicked = GUI.Button(btn, sb.ToString());

                GUI.enabled = prev;

                if (clicked && BuildPlacementManager.Instance != null)
                    BuildPlacementManager.Instance.SetSelected(item);

                iy += rowH + 6;
                drawn++;
                if (drawn > 90) break;
            }

            if (drawn == 0)
                GUI.Label(new Rect(0, iy, innerW - 18, 18), "No items match your search.");
        }

        viewRect.height = Mathf.Max(innerH, iy + 10);
        GUI.EndScrollView();

        GUI.Label(new Rect(panelRect.x + 10, panelRect.yMax - 18, panelWidth - 20, 18),
            "Tip: Select a build item, then click a grid cell to place a blueprint.");
    }

    BuildCategory[] DiscoverFromResources(string path)
    {
        BuildItemDefinition[] all = Resources.LoadAll<BuildItemDefinition>(path);
        if (all == null || all.Length == 0) return new BuildCategory[0];

        Dictionary<string, List<BuildItemDefinition>> grouped = new Dictionary<string, List<BuildItemDefinition>>(StringComparer.OrdinalIgnoreCase);

        for (int i = 0; i < all.Length; i++)
        {
            var item = all[i];
            if (item == null) continue;

            string cat = GetCategoryName(item);
            if (string.IsNullOrEmpty(cat)) cat = "Uncategorized";

            if (!grouped.TryGetValue(cat, out var list))
            {
                list = new List<BuildItemDefinition>();
                grouped[cat] = list;
            }
            list.Add(item);
        }

        List<string> catNames = new List<string>(grouped.Keys);
        catNames.Sort(StringComparer.OrdinalIgnoreCase);

        BuildCategory[] result = new BuildCategory[catNames.Count];

        for (int c = 0; c < catNames.Count; c++)
        {
            string name = catNames[c];
            var list = grouped[name];

            list.Sort((a, b) =>
            {
                string an = a != null ? (a.displayName ?? a.name) : "";
                string bn = b != null ? (b.displayName ?? b.name) : "";
                return StringComparer.OrdinalIgnoreCase.Compare(an, bn);
            });

            result[c] = new BuildCategory { name = name, items = list.ToArray() };
        }

        return result;
    }

    string GetCategoryName(BuildItemDefinition item)
    {
        string fromMeta = TryReadStringMember(item, "category")
                       ?? TryReadStringMember(item, "categoryName")
                       ?? TryReadStringMember(item, "Category")
                       ?? TryReadStringMember(item, "CategoryName");

        if (!string.IsNullOrEmpty(fromMeta))
            return fromMeta.Trim();

        string n = item.name ?? "";
        int us = n.IndexOf('_');
        if (us > 0) return n.Substring(0, us).Trim();

        string dn = item.displayName ?? "";
        int colon = dn.IndexOf(':');
        if (colon > 0) return dn.Substring(0, colon).Trim();

        return "Uncategorized";
    }

    string TryReadStringMember(object obj, string memberName)
    {
        if (obj == null) return null;
        Type t = obj.GetType();

        FieldInfo f = t.GetField(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (f != null && f.FieldType == typeof(string))
            return f.GetValue(obj) as string;

        PropertyInfo p = t.GetProperty(memberName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        if (p != null && p.PropertyType == typeof(string) && p.GetIndexParameters().Length == 0)
        {
            try { return p.GetValue(obj, null) as string; } catch { }
        }

        return null;
    }

    string CostString(ResourceCost[] costs)
    {
        if (costs == null || costs.Length == 0) return "(Free)";

        costSb.Length = 0;
        costSb.Append("[");

        for (int i = 0; i < costs.Length; i++)
        {
            if (i > 0) costSb.Append(", ");
            costSb.Append(costs[i].type);
            costSb.Append(" ");
            costSb.Append(costs[i].amount);
        }

        costSb.Append("]");
        return costSb.ToString();
    }

    void TrySyncGrid(bool visible)
    {
        MonoBehaviour[] behaviours = FindObjectsOfType<MonoBehaviour>();

        for (int i = 0; i < behaviours.Length; i++)
        {
            var mb = behaviours[i];
            if (mb == null) continue;

            Type t = mb.GetType();
            string n = t.Name;

            if (n.IndexOf("BuildGrid", StringComparison.OrdinalIgnoreCase) < 0)
                continue;

            string[] methods = { "SetGridVisible", "SetVisible", "SetShown", "SetShowGrid", "SetBuildMode", "SetEnabled" };

            for (int m = 0; m < methods.Length; m++)
            {
                var mi = t.GetMethod(methods[m], new Type[] { typeof(bool) });
                if (mi != null) { mi.Invoke(mb, new object[] { visible }); return; }
            }
        }
    }
}

==============================
FILE: ConstructionManager.cs
==============================

using UnityEngine;

public class ConstructionManager : MonoBehaviour
{
    // This will eventually track all active construction sites
    // and update their progress each frame.

    void Awake()
    {
        Debug.Log("ConstructionManager initialized");
    }
}

==============================
FILE: EconomyUI.cs
==============================

using UnityEngine;
using UnityEngine.UI;

public class EconomyUI : MonoBehaviour
{
    [Header("Team IDs")]
    public int team1ID = 0;
    public int team2ID = 1;

    [Header("UI Text")]
    public Text team1GoldText;
    public Text team1FoodText;
    public Text team2GoldText;
    public Text team2FoodText;

    void Update()
    {
        UpdateTeamUI(team1ID, team1GoldText, team1FoodText);
        UpdateTeamUI(team2ID, team2GoldText, team2FoodText);
    }

    void UpdateTeamUI(int teamID, Text goldText, Text foodText)
    {
        int gold = TeamResources.Instance.GetResource(teamID, ResourceType.Gold);
        int food = TeamResources.Instance.GetResource(teamID, ResourceType.Food);

        goldText.text = $"Team {teamID + 1} Gold: {gold}";
        foodText.text = $"Team {teamID + 1} Food: {food}";
    }
}


==============================
FILE: IMGUIInputBlocker.cs
==============================

using System.Collections.Generic;
using UnityEngine;

public static class IMGUIInputBlocker
{
    private static readonly List<Rect> rects = new List<Rect>(8);
    private static int lastRegisterFrame = -999;

    /// <summary>
    /// Register a panel rect each frame from OnGUI.
    /// </summary>
    public static void Register(Rect r)
    {
        if (Time.frameCount != lastRegisterFrame)
        {
            rects.Clear();
            lastRegisterFrame = Time.frameCount;
        }

        rects.Add(r);
    }

    /// <summary>
    /// Returns true if the mouse is over any registered IMGUI panel.
    /// Works in Update by using last frame's registered rects.
    /// </summary>
    public static bool IsMouseOverUI(Vector3 mouseScreenPos)
    {
        // If no panels have registered recently, don't block anything.
        // During Update, lastRegisterFrame will usually be (Time.frameCount - 1) when visible.
        if (Time.frameCount - lastRegisterFrame > 1)
            return false;

        // Convert screen coords (bottom-left) -> IMGUI coords (top-left)
        Vector2 guiPos = new Vector2(mouseScreenPos.x, Screen.height - mouseScreenPos.y);

        for (int i = 0; i < rects.Count; i++)
        {
            if (rects[i].Contains(guiPos))
                return true;
        }

        return false;
    }
}


==============================
FILE: MainMenuUI.cs
==============================

using System;
using UnityEngine;
using UnityEngine.SceneManagement;

public class MainMenuUI : MonoBehaviour
{
    [Header("Toggle")]
    public bool show = true;
    public KeyCode toggleKey = KeyCode.Escape;

    [Header("Panel Layout (Centered)")]
    public int panelWidth = 300;
    public int panelHeight = 400;
    public int buttonHeight = 40;
    public int buttonSpacing = 10;

    [Header("Styles")]
    public int fontSize = 18;
    private GUIStyle buttonStyle;
    private GUIStyle boxStyle;
    private GUIStyle labelStyle;
    private bool stylesInitialized = false;

    [Header("Load Menu")]
    public string[] loadableScenes;
    private bool showLoadMenu = false;

    [Header("Credits")]
    [TextArea(5, 10)]
    public string creditsText =
        "Twaitsy";
    private bool showCredits = false;

    public bool IsVisible => show;
    public void SetVisible(bool visible) => show = visible;
    public void ToggleVisible() => show = !show;

    void Update()
    {
        if (Input.GetKeyDown(toggleKey))
            ToggleVisible();
    }

    void OnGUI()
    {
        if (!show)
            return;

        // Lazy initialization — safe in Unity 2019
        if (!stylesInitialized)
        {
            InitStyles();
            stylesInitialized = true;
        }

        if (showLoadMenu)
        {
            DrawLoadMenu();
            return;
        }

        if (showCredits)
        {
            DrawCredits();
            return;
        }

        DrawMainMenu();
    }

    private void InitStyles()
    {
        buttonStyle = new GUIStyle(GUI.skin.button)
        {
            fontSize = fontSize,
            alignment = TextAnchor.MiddleCenter,
            fontStyle = FontStyle.Bold
        };

        boxStyle = new GUIStyle(GUI.skin.box)
        {
            fontSize = fontSize + 4,
            alignment = TextAnchor.UpperCenter,
            fontStyle = FontStyle.Bold
        };

        labelStyle = new GUIStyle(GUI.skin.label)
        {
            fontSize = fontSize,
            wordWrap = true,
            alignment = TextAnchor.UpperLeft
        };
    }

    private void DrawMainMenu()
    {
        float left = (Screen.width - panelWidth) / 2f;
        float top = (Screen.height - panelHeight) / 2f;
        Rect panelRect = new Rect(left, top, panelWidth, panelHeight);

        GUI.Box(panelRect, "MAIN MENU", boxStyle);

        float x = panelRect.x + 20;
        float y = panelRect.y + 40;
        float btnWidth = panelWidth - 40;

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "New Game", buttonStyle))
        {
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }
        y += buttonHeight + buttonSpacing;

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "Load Game", buttonStyle))
        {
            showLoadMenu = true;
        }
        y += buttonHeight + buttonSpacing;

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "Settings", buttonStyle))
        {
            Debug.Log("Settings selected");
        }
        y += buttonHeight + buttonSpacing;

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "Credits", buttonStyle))
        {
            showCredits = true;
        }
        y += buttonHeight + buttonSpacing;

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "Quit", buttonStyle))
        {
            Application.Quit();
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#endif
        }
    }

    private void DrawLoadMenu()
    {
        float left = (Screen.width - panelWidth) / 2f;
        float top = (Screen.height - panelHeight) / 2f;
        Rect panelRect = new Rect(left, top, panelWidth, panelHeight);

        GUI.Box(panelRect, "LOAD GAME", boxStyle);

        float x = panelRect.x + 20;
        float y = panelRect.y + 40;
        float btnWidth = panelWidth - 40;

        foreach (string sceneName in loadableScenes)
        {
            if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), $"Load {sceneName}", buttonStyle))
            {
                SceneManager.LoadScene(sceneName);
            }
            y += buttonHeight + buttonSpacing;
        }

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "Back", buttonStyle))
        {
            showLoadMenu = false;
        }
    }

    private void DrawCredits()
    {
        float left = (Screen.width - panelWidth) / 2f;
        float top = (Screen.height - panelHeight) / 2f;
        Rect panelRect = new Rect(left, top, panelWidth, panelHeight);

        GUI.Box(panelRect, "CREDITS", boxStyle);

        float x = panelRect.x + 20;
        float y = panelRect.y + 40;
        float contentHeight = panelHeight - 80;
        float btnWidth = panelWidth - 40;

        GUI.Label(new Rect(x, y, btnWidth, contentHeight - buttonHeight - buttonSpacing),
                  creditsText, labelStyle);

        y += contentHeight - buttonHeight;

        if (GUI.Button(new Rect(x, y, btnWidth, buttonHeight), "Back", buttonStyle))
        {
            showCredits = false;
        }
    }
}

==============================
FILE: MapVisualsBootstrap.cs
==============================

using UnityEngine;

public class MapVisualsBootstrap : MonoBehaviour
{
    public int teamCount = 6;
    public Vector3 center = Vector3.zero;
    public float hqRadius = 18f;

    [Header("Roads")]
    public float roadWidth = 2.2f;
    public float roadThickness = 0.05f;

    [Header("Territories")]
    public float territoryRadius = 28f;
    public float territoryAlpha = 0.12f;

    [Header("Landmark")]
    public float landmarkHeight = 6f;

    void Start()
    {
        CreateLandmark();
        CreateRoads();
        CreateTerritories();
    }

    void CreateLandmark()
    {
        var obelisk = GameObject.CreatePrimitive(PrimitiveType.Cube);
        obelisk.name = "CentralLandmark";
        obelisk.transform.position = center + new Vector3(0f, landmarkHeight * 0.5f, 0f);
        obelisk.transform.localScale = new Vector3(2f, landmarkHeight, 2f);

        var r = obelisk.GetComponent<Renderer>();
        if (r != null && r.material != null) r.material.color = new Color(0.15f, 0.15f, 0.18f);
    }

    void CreateRoads()
    {
        for (int teamID = 0; teamID < teamCount; teamID++)
        {
            float angle = (360f / teamCount) * teamID;
            Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;

            Vector3 a = center;
            Vector3 b = center + dir * hqRadius;

            CreateRoadSegment(teamID, a, b);
        }
    }

    void CreateRoadSegment(int teamID, Vector3 a, Vector3 b)
    {
        Vector3 mid = (a + b) * 0.5f;
        float len = Vector3.Distance(a, b);

        var road = GameObject.CreatePrimitive(PrimitiveType.Cube);
        road.name = $"Road_Team{teamID}";
        road.transform.position = mid + new Vector3(0f, roadThickness * 0.5f, 0f);
        road.transform.localScale = new Vector3(roadWidth, roadThickness, len);
        road.transform.rotation = Quaternion.LookRotation((b - a).normalized, Vector3.up);

        Destroy(road.GetComponent<Collider>());

        var r = road.GetComponent<Renderer>();
        if (r != null && r.material != null)
            r.material.color = new Color(0.08f, 0.08f, 0.09f);
    }

    void CreateTerritories()
    {
        if (TeamColorManager.Instance == null) return;

        for (int teamID = 0; teamID < teamCount; teamID++)
        {
            float angle = (360f / teamCount) * teamID;
            Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;

            Vector3 pos = center + dir * (hqRadius * 0.85f);

            var territory = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
            territory.name = $"Territory_Team{teamID}";
            territory.transform.position = pos + new Vector3(0f, 0.01f, 0f);
            territory.transform.localScale = new Vector3(territoryRadius, 0.02f, territoryRadius);

            Destroy(territory.GetComponent<Collider>());

            Color c = TeamColorManager.Instance.GetTeamColor(teamID);
            c.a = 1f;

            var r = territory.GetComponent<Renderer>();
            if (r != null && r.material != null)
            {
                r.material.color = Color.Lerp(c, Color.white, 0.35f);
                // Transparency hack in Standard shader can be finicky in 2019;
                // if it renders opaque, set Rendering Mode = Transparent in the material manually.
            }
        }
    }
}


==============================
FILE: Minimap.cs
==============================

using UnityEngine;
using System.Collections.Generic;

public class Minimap : MonoBehaviour
{
    [Header("Map")]
    public Vector2 worldMin = new Vector2(-100, -100);
    public Vector2 worldMax = new Vector2(100, 100);

    [Header("UI")]
    public Rect minimapRect = new Rect(10, 10, 200, 200);

    [Header("Icons")]
    public float dotSize = 4f;

    Camera mainCam;

    void Awake()
    {
        mainCam = Camera.main;
    }

    void OnGUI()
    {
        GUI.Box(minimapRect, "Minimap");

        DrawEntities<Unit>();
        DrawEntities<Turret>();
        DrawEntities<ResourceNode>();

        HandleClick();
    }

    void DrawEntities<T>() where T : MonoBehaviour
    {
        T[] all = GameObject.FindObjectsOfType<T>();

        foreach (var e in all)
        {
            Vector3 pos = e.transform.position;
            Vector2 p = WorldToMinimap(pos);

            Color c = Color.white;

            if (e.TryGetComponent<Unit>(out var u))
                c = TeamColorUtils.Get(u.teamID);
            else if (e.TryGetComponent<Turret>(out var t))
                c = TeamColorUtils.Get(t.teamID);
            else if (e is ResourceNode)
                c = Color.yellow;

            DrawDot(p, c);
        }
    }

    Vector2 WorldToMinimap(Vector3 world)
    {
        float x = Mathf.InverseLerp(worldMin.x, worldMax.x, world.x);
        float y = Mathf.InverseLerp(worldMin.y, worldMax.y, world.z);

        return new Vector2(
            minimapRect.x + x * minimapRect.width,
            minimapRect.y + (1f - y) * minimapRect.height
        );
    }

    void DrawDot(Vector2 pos, Color c)
    {
        Color prev = GUI.color;
        GUI.color = c;
        GUI.DrawTexture(
            new Rect(pos.x, pos.y, dotSize, dotSize),
            Texture2D.whiteTexture
        );
        GUI.color = prev;
    }

    void HandleClick()
    {
        if (!Event.current.isMouse || Event.current.type != EventType.MouseDown)
            return;

        if (!minimapRect.Contains(Event.current.mousePosition))
            return;

        Vector2 local = Event.current.mousePosition;
        float nx = (local.x - minimapRect.x) / minimapRect.width;
        float ny = 1f - ((local.y - minimapRect.y) / minimapRect.height);

        float wx = Mathf.Lerp(worldMin.x, worldMax.x, nx);
        float wz = Mathf.Lerp(worldMin.y, worldMax.y, ny);

        Vector3 camPos = mainCam.transform.position;
        mainCam.transform.position = new Vector3(wx, camPos.y, wz);
    }
}


==============================
FILE: NeonRing.cs
==============================

using UnityEngine;

public class NeonRing : MonoBehaviour
{
    public int teamID;
    public VisualKind kind = VisualKind.Unit;

    public float radius = 0.9f;
    public float height = 0.03f;
    public float yOffset = -0.48f;

    [Range(0f, 6f)] public float emissionStrength = 2.0f;

    static readonly int ColorID = Shader.PropertyToID("_Color");
    static readonly int EmissionID = Shader.PropertyToID("_EmissionColor");

    void Start()
    {
        var ring = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
        ring.name = "NeonRing";
        ring.transform.SetParent(transform, false);
        ring.transform.localPosition = new Vector3(0f, yOffset, 0f);
        ring.transform.localScale = new Vector3(radius, height, radius);

        var col = ring.GetComponent<Collider>();
        if (col != null) Destroy(col);

        if (TeamColorManager.Instance == null) return;

        Color team = TeamColorManager.Instance.GetTeamColor(teamID);
        Color c = team;

        if (kind == VisualKind.Civilian) c = Color.Lerp(team, Color.white, 0.55f);
        if (kind == VisualKind.Building) c = Color.Lerp(team, Color.black, 0.2f);

        var r = ring.GetComponent<Renderer>();
        if (r != null)
        {
            var block = new MaterialPropertyBlock();
            r.GetPropertyBlock(block);
            block.SetColor(ColorID, c);
            block.SetColor(EmissionID, c * emissionStrength);
            r.SetPropertyBlock(block);
        }
    }
}


==============================
FILE: ResourceVisualBuilder.cs
==============================

using UnityEngine;

[ExecuteAlways]
public class ResourceVisualBuilder : MonoBehaviour
{
    public ResourceType type;
    public Material material;
    public bool rebuild;

    void Update()
    {
        if (!rebuild) return;
        rebuild = false;
        Build();
    }

    void Build()
    {
        // Clear children
        for (int i = transform.childCount - 1; i >= 0; i--)
        {
            if (Application.isPlaying)
                Destroy(transform.GetChild(i).gameObject);
            else
                DestroyImmediate(transform.GetChild(i).gameObject);
        }

        switch (type)
        {
            case ResourceType.Wood:
                MakeLogs(5);
                break;
            case ResourceType.Stone:
                MakeCluster(PrimitiveType.Sphere, 4);
                break;
            case ResourceType.IronOre:
                MakeOre();
                break;
            case ResourceType.Silicon:
                MakeShards(5);
                break;
            case ResourceType.Lithium:
                MakeCrystal(1, 4);
                break;
            case ResourceType.Coal:
                MakeCluster(PrimitiveType.Sphere, 5);
                break;
            case ResourceType.Copper:
                MakeCluster(PrimitiveType.Sphere, 6);
                break;
            default:
                MakeCluster(PrimitiveType.Cube, 3);
                break;
        }

        ApplyMaterial();
    }

    void ApplyMaterial()
    {
        if (material == null) return;
        foreach (var r in GetComponentsInChildren<Renderer>())
            r.sharedMaterial = material;
    }

    void MakeLogs(int count)
    {
        for (int i = 0; i < count; i++)
        {
            var go = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
            go.transform.SetParent(transform, false);
            go.transform.localScale = new Vector3(0.6f, 0.35f, 0.6f);
            go.transform.localRotation = Quaternion.Euler(90f, 0f, 0f);
            go.transform.localPosition = new Vector3(
                Random.Range(-0.6f, 0.6f),
                0.2f + i * 0.05f,
                Random.Range(-0.6f, 0.6f)
            );
        }
    }

    void MakeCluster(PrimitiveType prim, int count)
    {
        for (int i = 0; i < count; i++)
        {
            var go = GameObject.CreatePrimitive(prim);
            go.transform.SetParent(transform, false);
            go.transform.localScale = Vector3.one * Random.Range(0.6f, 1.2f);
            go.transform.localPosition = new Vector3(
                Random.Range(-0.6f, 0.6f),
                0.4f,
                Random.Range(-0.6f, 0.6f)
            );
        }
    }

    void MakeOre()
    {
        var baseRock = GameObject.CreatePrimitive(PrimitiveType.Cube);
        baseRock.transform.SetParent(transform, false);
        baseRock.transform.localScale = new Vector3(1.4f, 1.0f, 1.2f);
        baseRock.transform.localPosition = new Vector3(0f, 0.5f, 0f);
        baseRock.transform.localRotation = Quaternion.Euler(0f, 25f, 0f);

        for (int i = 0; i < 4; i++)
        {
            var chunk = GameObject.CreatePrimitive(PrimitiveType.Cube);
            chunk.transform.SetParent(transform, false);
            chunk.transform.localScale = Vector3.one * Random.Range(0.2f, 0.35f);
            chunk.transform.localPosition = new Vector3(
                Random.Range(-0.6f, 0.6f),
                Random.Range(0.3f, 0.9f),
                Random.Range(-0.5f, 0.5f)
            );
        }
    }

    void MakeShards(int count)
    {
        for (int i = 0; i < count; i++)
        {
            var shard = GameObject.CreatePrimitive(PrimitiveType.Cube);
            shard.transform.SetParent(transform, false);
            shard.transform.localScale = new Vector3(
                Random.Range(0.15f, 0.25f),
                Random.Range(0.8f, 1.6f),
                Random.Range(0.15f, 0.25f)
            );
            shard.transform.localPosition = new Vector3(
                Random.Range(-0.5f, 0.5f),
                shard.transform.localScale.y * 0.5f,
                Random.Range(-0.5f, 0.5f)
            );
            shard.transform.localRotation = Quaternion.Euler(
                Random.Range(-10f, 10f),
                Random.Range(0f, 360f),
                Random.Range(-10f, 10f)
            );
        }
    }

    void MakeCrystal(int coreCount, int spikeCount)
    {
        for (int i = 0; i < coreCount; i++)
        {
            var core = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            core.transform.SetParent(transform, false);
            core.transform.localScale = Vector3.one * 1.0f;
            core.transform.localPosition = new Vector3(0f, 0.6f, 0f);
        }

        for (int i = 0; i < spikeCount; i++)
        {
            var spike = GameObject.CreatePrimitive(PrimitiveType.Cube);
            spike.transform.SetParent(transform, false);
            spike.transform.localScale = new Vector3(0.12f, 1.2f, 0.12f);
            float angle = i * (360f / spikeCount);
            Vector3 dir = Quaternion.Euler(0f, angle, 0f) * Vector3.forward;
            spike.transform.localPosition = new Vector3(dir.x * 0.5f, 0.8f, dir.z * 0.5f);
            spike.transform.localRotation = Quaternion.LookRotation(dir) * Quaternion.Euler(-20f, 0f, 0f);
        }
    }
}


==============================
FILE: SciFiTeamStyler.cs
==============================

using UnityEngine;

public class SciFiTeamStyler : MonoBehaviour
{
    public static SciFiTeamStyler Instance;

    [Header("Neon Strength")]
    [Range(0f, 6f)] public float emissionStrength = 2.2f;

    [Header("Type Tints")]
    [Range(0f, 1f)] public float civilianLighten = 0.45f;
    [Range(0f, 1f)] public float buildingDarken = 0.35f;

    static readonly int ColorID = Shader.PropertyToID("_Color");
    static readonly int EmissionID = Shader.PropertyToID("_EmissionColor");

    void Awake()
    {
        Instance = this;
    }

    public void Apply(GameObject obj, int teamID, VisualKind kind)
    {
        if (TeamColorManager.Instance == null) return;

        Color team = TeamColorManager.Instance.GetTeamColor(teamID);
        Color baseColor = team;

        // Sci-fi type grading
        if (kind == VisualKind.Civilian) baseColor = Color.Lerp(team, Color.white, civilianLighten);
        if (kind == VisualKind.Building) baseColor = Color.Lerp(team, Color.black, buildingDarken);

        // Emission for bloom/glow
        Color emissive = baseColor * emissionStrength;

        var block = new MaterialPropertyBlock();
        var renderers = obj.GetComponentsInChildren<Renderer>(true);

        foreach (var r in renderers)
        {
            if (r == null) continue;
            r.GetPropertyBlock(block);

            block.SetColor(ColorID, baseColor);
            block.SetColor(EmissionID, emissive);

            r.SetPropertyBlock(block);
        }
    }
}


==============================
FILE: SelectionManager.cs
==============================

using UnityEngine;

public class SelectionManager : MonoBehaviour
{
    public static SelectionManager Instance;

    [Header("References")]
    public Camera mainCamera;
    public UnitInspectorUI inspectorUI;

    GameObject currentSelection;

    void Awake()
    {
        Instance = this;

        if (mainCamera == null)
            mainCamera = Camera.main;
    }

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
            TrySelect();

        if (Input.GetMouseButtonDown(1))
            TryIssueAttackOrder();
    }

    // -------------------------------------------------
    // SELECTION
    // -------------------------------------------------
    void TrySelect()
    {
        Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);

        if (Physics.Raycast(ray, out RaycastHit hit, 500f))
        {
            Selectable sel = hit.collider.GetComponentInParent<Selectable>();
            if (sel != null)
            {
                SetSelection(sel.gameObject);
                sel.SetSelected(true);
                return;
            }
        }

        ClearSelection();
    }

    // -------------------------------------------------
    // ATTACK ORDERS
    // -------------------------------------------------
    void TryIssueAttackOrder()
    {
        if (currentSelection == null)
            return;

        if (!currentSelection.TryGetComponent<UnitCombatController>(out var combat))
            return;

        Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);

        if (Physics.Raycast(ray, out RaycastHit hit, 500f))
        {
            Attackable atk = hit.collider.GetComponentInParent<Attackable>();

            if (atk != null)
            {
                combat.SetManualTarget(atk);
                return;
            }
        }

        // Right-clicked ground ? clear order
        combat.ClearManualTarget();
    }

    // -------------------------------------------------
    // INTERNAL
    // -------------------------------------------------
    void SetSelection(GameObject go)
    {
        if (currentSelection == go) return;

        if (currentSelection != null)
        {
            var prev = currentSelection.GetComponentInParent<Selectable>();
            if (prev != null) prev.SetSelected(false);
        }

        currentSelection = go;
        inspectorUI.SetSelected(go);
    }

    void ClearSelection()
    {
        if (currentSelection != null)
        {
            var prev = currentSelection.GetComponentInParent<Selectable>();
            if (prev != null) prev.SetSelected(false);
        }

        currentSelection = null;
        inspectorUI.SetSelected(null);
    }
}


==============================
FILE: SelectionRing.cs
==============================

using UnityEngine;

public class SelectionRing : MonoBehaviour
{
    public int teamID;
    public VisualKind kind = VisualKind.Unit;

    [Header("Ring")]
    public float radius = 0.75f;
    public float height = 0.05f;
    public float yOffset = -0.45f;

    void Start()
    {
        CreateRing();
    }

    void CreateRing()
    {
        var ring = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
        ring.name = "Ring";
        ring.transform.SetParent(transform, false);

        ring.transform.localPosition = new Vector3(0f, yOffset, 0f);
        ring.transform.localScale = new Vector3(radius, height, radius);

        // Remove collider (important)
        var col = ring.GetComponent<Collider>();
        if (col != null) Destroy(col);

        // Color by team + type
        if (TeamColorManager.Instance != null)
        {
            Color baseColor = TeamColorManager.Instance.GetTeamColor(teamID);
            Color final = baseColor;

            if (kind == VisualKind.Civilian) final = Color.Lerp(baseColor, Color.white, 0.55f);
            if (kind == VisualKind.Building) final = Color.Lerp(baseColor, Color.black, 0.15f);

            var rend = ring.GetComponent<Renderer>();
            if (rend != null && rend.material != null) rend.material.color = final;
        }
    }
}


==============================
FILE: TaskBoardUI.cs
==============================

// =============================================================
// TaskBoardUI.cs
//
// DEPENDENCIES:
// - JobManager: GetRoleCounts(), GetActiveConstructionSiteCount()
// - CivilianRole: expects Gatherer, Builder, Hauler, Idle
// - TeamStorageManager: building-only stored/capacity/reserved totals
// - IMGUIInputBlocker: prevents clicks through the panel
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add new roles, update the display line for civilians.
// - If storage logic changes, update the resource lines accordingly.
// =============================================================

using System;
using System.Collections.Generic;
using UnityEngine;

public class TaskBoardUI : MonoBehaviour
{
    public int playerTeamID = 0;

    [Header("Toggle")]
    public bool show = true;
    public KeyCode toggleKey = KeyCode.Tab;

    [Header("Panel Layout (Bottom Left)")]
    public int panelWidth = 460;
    public int panelHeight = 320;
    public int marginLeft = 12;
    public int marginBottom = 12;

    [Header("Display")]
    public int maxResourceLines = 14;

    void Update()
    {
        if (Input.GetKeyDown(toggleKey))
            show = !show;
    }

    void OnGUI()
    {
        if (!show) return;

        float left = marginLeft;
        float top = Screen.height - panelHeight - marginBottom;

        Rect panelRect = new Rect(left, top, panelWidth, panelHeight);
        IMGUIInputBlocker.Register(panelRect);

        GUI.Box(panelRect, $"TASK BOARD (Team {playerTeamID})");

        float x = panelRect.x + 10;
        float y = panelRect.y + 24;

        if (JobManager.Instance != null)
        {
            Dictionary<CivilianRole, int> counts = JobManager.Instance.GetRoleCounts(playerTeamID);

            int gatherers = counts.ContainsKey(CivilianRole.Gatherer) ? counts[CivilianRole.Gatherer] : 0;
            int builders = counts.ContainsKey(CivilianRole.Builder) ? counts[CivilianRole.Builder] : 0;
            int haulers = counts.ContainsKey(CivilianRole.Hauler) ? counts[CivilianRole.Hauler] : 0;
            int idles = counts.ContainsKey(CivilianRole.Idle) ? counts[CivilianRole.Idle] : 0;

            GUI.Label(new Rect(x, y, panelWidth - 20, 20),
                $"Civilians: Gatherer {gatherers} | Builder {builders} | Hauler {haulers} | Idle {idles}");
            y += 22;

            int sites = JobManager.Instance.GetActiveConstructionSiteCount(playerTeamID);
            GUI.Label(new Rect(x, y, panelWidth - 20, 20), $"Construction Sites: {sites}");
            y += 26;
        }
        else
        {
            int gatherers = 0, builders = 0, haulers = 0, idles = 0;
            var all = FindObjectsOfType<Civilian>();
            for (int i = 0; i < all.Length; i++)
            {
                var c = all[i];
                if (c == null) continue;
                if (c.teamID != playerTeamID) continue;
                switch (c.role)
                {
                    case CivilianRole.Gatherer: gatherers++; break;
                    case CivilianRole.Builder: builders++; break;
                    case CivilianRole.Hauler: haulers++; break;
                    case CivilianRole.Idle: idles++; break;
                }
            }

            GUI.Label(new Rect(x, y, panelWidth - 20, 20),
                $"Civilians: Gatherer {gatherers} | Builder {builders} | Hauler {haulers} | Idle {idles}");
            y += 22;
        }

        if (TeamStorageManager.Instance == null)
        {
            GUI.Label(new Rect(x, y, panelWidth - 20, 20), "TeamStorageManager missing (add it to the scene).");
            return;
        }

        GUI.Label(new Rect(x, y, panelWidth - 20, 20), "Stored in Buildings (Stored/Cap)  [Reserved]");
        y += 20;

        int lines = 0;
        foreach (ResourceType t in Enum.GetValues(typeof(ResourceType)))
        {
            int stored = TeamStorageManager.Instance.GetTotalStoredInBuildings(playerTeamID, t);
            int cap = TeamStorageManager.Instance.GetTotalCapacityInBuildings(playerTeamID, t);
            int reserved = TeamStorageManager.Instance.GetReservedTotal(playerTeamID, t);

            if (stored == 0 && cap == 0 && reserved == 0) continue;

            string line = $"{t}: {stored}/{cap}";
            if (reserved > 0) line += $"  [{reserved}]";
            if (cap > 0 && stored >= cap) line += " (FULL)";
            if (cap == 0) line += " (NO STORAGE)";

            GUI.Label(new Rect(x, y, panelWidth - 20, 18), line);
            y += 18;

            lines++;
            if (lines >= maxResourceLines) break;
            if (y > panelRect.yMax - 20) break;
        }

        if (lines == 0)
            GUI.Label(new Rect(x, y, panelWidth - 20, 18), "No storage buildings registered for this team.");
    }
}

==============================
FILE: TeamBootstrap.cs
==============================

using UnityEngine;

/// <summary>
/// TeamBootstrap
///
/// PURPOSE:
/// - Initialize each Team object at runtime.
/// - Spawn HQs for teams missing one.
/// - Spawn starting workers.
/// - Attach AI subsystems to AI teams.
///
/// DEPENDENCIES:
/// - Team.cs:
///     * Provides teamID, teamType, hqRoot, unitsRoot.
/// - Building.cs:
///     * HQ prefab must contain a Building component for teamID assignment.
/// - Unit.cs:
///     * Worker prefab must contain a Unit component for teamID assignment.
/// - AIPlayer / AIEconomy / AIMilitary / AIBuilder / AIResourceManager / AIThreatDetector:
///     * Added automatically to AI teams if missing.
/// - GameManager:
///     * Detects teams after bootstrap runs.
/// - TeamColorManager (optional):
///     * HQ and workers may use TeamVisual to apply colors.
/// - TeamVisual (optional):
///     * If present on prefabs, will apply team colors automatically.
///
/// NOTES FOR FUTURE MAINTENANCE:
/// - This script NEVER deletes teams.
/// - This script NEVER enforces a maximum team count.
/// - This script NEVER modifies teamIDs.
/// - This script NEVER spawns UI, camera, or global systems.
/// - HQ and worker prefabs MUST have correct components (Building / Unit).
/// - If you add new AI subsystems, include them in SetupAI().
/// - If you add new team roots (e.g., Vehicles), extend SetupWorkers().
///
/// ARCHITECTURE:
/// - Runs once at scene start.
/// - Safe to use with any number of Team objects.
/// - Designed to work with your multi-team RTS architecture.
/// </summary>
public class TeamBootstrap : MonoBehaviour
{
    [Header("Prefabs")]
    [Tooltip("HQ building prefab for each team.")]
    public GameObject hqPrefab;

    [Tooltip("Worker unit prefab spawned at game start.")]
    public GameObject workerPrefab;

    [Header("Starting Units")]
    [Tooltip("How many workers each team starts with.")]
    public int startingWorkers = 3;

    [Header("Spawn Offsets")]
    [Tooltip("Offset applied when spawning HQs.")]
    public Vector3 hqSpawnOffset = Vector3.zero;

    [Tooltip("Offset applied when spawning workers relative to HQ.")]
    public Vector3 workerSpawnOffset = new Vector3(2f, 0f, 2f);

    void Start()
    {
        Team[] teams = FindObjectsOfType<Team>();

        foreach (var team in teams)
        {
            SetupHQ(team);
            SetupWorkers(team);
            SetupAI(team);
        }
    }

    // -------------------------------------------------------------
    // 1. HQ SETUP
    // -------------------------------------------------------------
    private void SetupHQ(Team team)
    {
        if (team.hqRoot == null)
        {
            Debug.LogWarning($"Team {team.teamID} has no HQ root. Expected: Team_X -> HQ.");
            return;
        }

        // Skip if HQ already exists
        if (team.hqRoot.childCount > 0)
            return;

        // Spawn HQ
        Vector3 spawnPos = team.hqRoot.position + hqSpawnOffset;
        GameObject hq = Instantiate(hqPrefab, spawnPos, Quaternion.identity);
        hq.transform.SetParent(team.hqRoot);

        // Assign team ownership via Building base class
        Building building = hq.GetComponent<Building>();
        if (building != null)
            building.teamID = team.teamID;

        Debug.Log($"Spawned HQ for Team {team.teamID}");
    }

    // -------------------------------------------------------------
    // 2. WORKER SETUP
    // -------------------------------------------------------------
    private void SetupWorkers(Team team)
    {
        if (workerPrefab == null)
            return;

        if (team.unitsRoot == null)
        {
            Debug.LogWarning($"Team {team.teamID} has no Units root. Expected: Team_X -> Units.");
            return;
        }

        // Spawn workers near HQ
        Transform hq = team.hqRoot.childCount > 0 ? team.hqRoot.GetChild(0) : null;
        if (hq == null)
            return;

        for (int i = 0; i < startingWorkers; i++)
        {
            Vector3 offset = workerSpawnOffset * i;
            Vector3 spawnPos = hq.position + offset;

            GameObject worker = Instantiate(workerPrefab, spawnPos, Quaternion.identity);
            worker.transform.SetParent(team.unitsRoot);

            // Assign team ownership
            Unit unit = worker.GetComponent<Unit>();
            if (unit != null)
                unit.teamID = team.teamID;
        }

        Debug.Log($"Spawned {startingWorkers} workers for Team {team.teamID}");
    }

    // -------------------------------------------------------------
    // 3. AI SETUP
    // -------------------------------------------------------------
    private void SetupAI(Team team)
    {
        if (team.teamType != TeamType.AI)
            return;

        // Add AI components ONLY if missing
        AddIfMissing<AIPlayer>(team.gameObject);
        AddIfMissing<AIEconomy>(team.gameObject);
        AddIfMissing<AIMilitary>(team.gameObject);
        AddIfMissing<AIBuilder>(team.gameObject);
        AddIfMissing<AIResourceManager>(team.gameObject);
        AddIfMissing<AIThreatDetector>(team.gameObject);

        Debug.Log($"AI scripts assigned to Team {team.teamID}");
    }

    private void AddIfMissing<T>(GameObject obj) where T : Component
    {
        if (obj.GetComponent<T>() == null)
            obj.AddComponent<T>();
    }
}

==============================
FILE: UnitInspectorUI.cs
==============================

// =============================================================
// UnitInspectorUI.cs
//
// PURPOSE:
// - On-screen inspector for the currently selected object.
// - Shows health, team, civilian/unit info, barracks queue, combat stance,
//   construction progress, storage contents, and turret info.
//
// DEPENDENCIES:
// - SelectionManager (or equivalent):
//      * Must call SetSelected(GameObject) when selection changes.
// - Barracks:
//      * Expected API:
//          - List<UnitProductionDefinition> producibleUnits
//          - bool CanQueue(UnitProductionDefinition def)
//          - void QueueUnit(UnitProductionDefinition def)
//          - float CurrentBuildTime
//          - float CurrentProgress
//          - void CancelLast()
// - UnitCombatController:
//      * Used for target display, stance, and "Attack Civilians" toggle.
//      * Must implement:
//          - string GetTargetStatus()
//          - bool canAttackCivilians
//          - void ToggleAttackCivilians()
//          - CombatStance stance
//          - void SetStance(CombatStance newStance)
// - Turret:
//      * Marker component for turret-specific UI.
// - Unit:
//      * Exposes teamID, combatEnabled, damage, attackRange.
// - Civilian:
//      * Exposes teamID.
// - ConstructionSite:
//      * Expected API:
//          - int teamID
//          - string GetStatusLine()
//          - ResourceCost[] GetRequiredCosts()
//          - int GetDeliveredAmount(ResourceType type)
// - ResourceStorageContainer:
//      * Expected API:
//          - int teamID
//          - int GetCapacity(ResourceType type)
//          - int GetStored(ResourceType type)
// - IHasHealth:
//      * Interface with:
//          - float CurrentHealth { get; }
//          - float MaxHealth { get; }
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you change any of the dependent APIs (Barracks, ConstructionSite, etc.),
//   update this UI to match.
// - Keep this script UI-only: do not put game logic here.
// - If you add new unit types or systems, add new DrawX() sections rather than
//   overloading existing ones.
// =============================================================

using UnityEngine;

public class UnitInspectorUI : MonoBehaviour
{
    [Header("Layout (OnGUI)")]
    public float width = 320f;
    public float height = 420f;
    public float padding = 10f;

    private GameObject selected;

    // Called by SelectionManager
    public void SetSelected(GameObject obj)
    {
        selected = obj;

        if (selected != null)
            Debug.Log("UnitInspectorUI: Selected " + selected.name);
        else
            Debug.Log("UnitInspectorUI: Selection cleared");
    }

    void OnGUI()
    {
        if (selected == null)
            return;

        Rect rect = new Rect(
            Screen.width - width - padding,
            Screen.height - height - padding,
            width,
            height
        );

        GUILayout.BeginArea(rect, GUI.skin.window);
        GUILayout.BeginVertical();

        DrawHeader();
        DrawHealth();
        DrawCivilian();
        DrawUnit();
        DrawBarracks();
        DrawCombat();
        DrawConstruction();
        DrawStorage();
        DrawTurret();
        DrawCombatStance();

        GUILayout.EndVertical();
        GUILayout.EndArea();
    }

    void DrawHeader()
    {
        GUILayout.Label(selected.name, GUI.skin.box);

        int team = GetTeamID();
        if (team >= 0)
            GUILayout.Label($"Team: {team}");
    }

    void DrawHealth()
    {
        if (selected.TryGetComponent<IHasHealth>(out var health))
        {
            GUILayout.Label($"Health: {health.CurrentHealth:0}/{health.MaxHealth:0}");
        }
    }

    void DrawCivilian()
    {
        if (selected.TryGetComponent<Civilian>(out var civ))
        {
            GUILayout.Space(6);
            GUILayout.Label("Civilian", GUI.skin.box);
            GUILayout.Label("Status: Active");
        }
    }

    void DrawUnit()
    {
        if (selected.TryGetComponent<Unit>(out var unit))
        {
            GUILayout.Space(6);
            GUILayout.Label("Unit", GUI.skin.box);
            GUILayout.Label($"Combat Enabled: {(unit.combatEnabled ? "Yes" : "No")}");
            GUILayout.Label($"Damage: {unit.damage}");
            GUILayout.Label($"Range: {unit.attackRange}");
        }
    }

    void DrawBarracks()
    {
        if (!selected.TryGetComponent<Barracks>(out var barracks))
            return;

        GUILayout.Space(6);
        GUILayout.Label("Barracks", GUI.skin.box);

        if (barracks.producibleUnits != null)
        {
            foreach (var def in barracks.producibleUnits)
            {
                if (def == null) continue;

                GUILayout.BeginHorizontal(GUI.skin.box);

                GUILayout.Label(def.unitName, GUILayout.Width(120));

                bool canAfford = barracks.CanQueue(def);
                GUI.enabled = canAfford;

                if (GUILayout.Button("Train"))
                {
                    barracks.QueueUnit(def);
                }

                GUI.enabled = true;
                GUILayout.EndHorizontal();

                if (def.costs != null)
                {
                    foreach (var c in def.costs)
                    {
                        GUILayout.Label($"  {c.type}: {c.amount}");
                    }
                }
            }
        }

        GUILayout.Space(4);
        GUILayout.Label("Queue", GUI.skin.box);

        if (barracks.CurrentBuildTime > 0f)
        {
            float pct = barracks.CurrentProgress / barracks.CurrentBuildTime;
            GUILayout.HorizontalSlider(pct, 0f, 1f);
        }

        if (GUILayout.Button("Cancel Last"))
        {
            barracks.CancelLast();
        }
    }

    void DrawCombat()
    {
        if (!selected.TryGetComponent<UnitCombatController>(out var combat))
            return;

        GUILayout.Space(6);
        GUILayout.Label("Combat", GUI.skin.box);

        GUILayout.Label("Target: " + combat.GetTargetStatus());

        bool newToggle = GUILayout.Toggle(
            combat.canAttackCivilians,
            "Attack Civilians"
        );

        if (newToggle != combat.canAttackCivilians)
        {
            combat.ToggleAttackCivilians();
        }
    }

    void DrawTurret()
    {
        if (!selected.TryGetComponent<Turret>(out var turret))
            return;

        GUILayout.Space(6);
        GUILayout.Label("Turret", GUI.skin.box);

        if (selected.TryGetComponent<UnitCombatController>(out var combat))
        {
            GUILayout.Label("Target: " + combat.GetTargetStatus());

            bool newToggle = GUILayout.Toggle(
                combat.canAttackCivilians,
                "Attack Civilians"
            );

            if (newToggle != combat.canAttackCivilians)
                combat.ToggleAttackCivilians();
        }
    }

    void DrawCombatStance()
    {
        if (!selected.TryGetComponent<UnitCombatController>(out var combat))
            return;

        GUILayout.Space(6);
        GUILayout.Label("Combat Stance", GUI.skin.box);

        var newStance = (UnitCombatController.CombatStance)
            GUILayout.SelectionGrid(
                (int)combat.stance,
                new[] { "Hold", "Guard", "Aggressive" },
                3
            );

        if (newStance != combat.stance)
            combat.SetStance(newStance);
    }

    void DrawConstruction()
    {
        if (selected.TryGetComponent<ConstructionSite>(out var site))
        {
            GUILayout.Space(6);
            GUILayout.Label("Construction", GUI.skin.box);
            GUILayout.Label(site.GetStatusLine());

            var costs = site.GetRequiredCosts();
            if (costs != null)
            {
                foreach (var c in costs)
                {
                    int delivered = site.GetDeliveredAmount(c.type);
                    GUILayout.Label($"{c.type}: {delivered}/{c.amount}");
                }
            }
        }
    }

    void DrawStorage()
    {
        if (selected.TryGetComponent<ResourceStorageContainer>(out var storage))
        {
            GUILayout.Space(6);
            GUILayout.Label("Storage", GUI.skin.box);
            foreach (ResourceType t in System.Enum.GetValues(typeof(ResourceType)))
            {
                int cap = storage.GetCapacity(t);
                if (cap <= 0) continue;
                int stored = storage.GetStored(t);
                GUILayout.Label($"{t}: {stored}/{cap}");
            }
        }
    }

    int GetTeamID()
    {
        if (selected.TryGetComponent<Unit>(out var unit)) return unit.teamID;
        if (selected.TryGetComponent<Civilian>(out var civ)) return civ.teamID;
        if (selected.TryGetComponent<ConstructionSite>(out var site)) return site.teamID;
        if (selected.TryGetComponent<ResourceStorageContainer>(out var storage)) return storage.teamID;
        return -1;
    }
}

==============================
FILE: WorldHealthBar.cs
==============================

using UnityEngine;

public class WorldHealthBar : MonoBehaviour
{
    [Header("Position")]
    public Vector3 offset = new Vector3(0f, 1.2f, 0f);

    [Header("Size")]
    public float width = 1.2f;
    public float height = 0.12f;
    public float depth = 0.08f;

    [Header("Display Rules")]
    public bool onlyShowForBuildings = true;
    public bool hideWhenFullHealth = false;

    [Header("Smoothing")]
    [Tooltip("Higher = snappier, lower = smoother. 0 disables smoothing.")]
    public float smoothSpeed = 18f;

    [Header("Sci-Fi Glow")]
    [Range(0f, 6f)] public float glowStrength = 1.8f;

    [Header("Billboard")]
    public bool billboardToCamera = true;

    private IHasHealth health;

    private Transform holder;
    private Transform barFill;
    private Transform barBack;

    private Renderer fillRenderer;
    private Renderer backRenderer;

    private float displayedT = 1f;

    private MaterialPropertyBlock mpbFill;
    private MaterialPropertyBlock mpbBack;

    static readonly int ColorID = Shader.PropertyToID("_Color");
    static readonly int EmissionID = Shader.PropertyToID("_EmissionColor");

    void Start()
    {
        health = GetComponent<IHasHealth>();
        if (health == null)
        {
            enabled = false;
            return;
        }

        if (onlyShowForBuildings && GetComponent<Building>() == null)
        {
            enabled = false;
            return;
        }

        mpbFill = new MaterialPropertyBlock();
        mpbBack = new MaterialPropertyBlock();

        CreateBar();
    }

    void LateUpdate()
    {
        if (health == null || holder == null) return;

        float rawT = Mathf.Clamp01(health.CurrentHealth / Mathf.Max(0.01f, health.MaxHealth));

        // Smooth the displayed value (prevents shimmer)
        if (smoothSpeed > 0f)
            displayedT = Mathf.Lerp(displayedT, rawT, 1f - Mathf.Exp(-smoothSpeed * Time.deltaTime));
        else
            displayedT = rawT;

        if (hideWhenFullHealth)
            holder.gameObject.SetActive(displayedT < 0.999f);

        // Update fill width + pivot so it shrinks from left-to-right
        if (barFill != null)
        {
            barFill.localScale = new Vector3(width * displayedT, height, depth);
            barFill.localPosition = new Vector3(-(width * 0.5f) + (width * displayedT * 0.5f), 0f, -0.001f);
        }

        // Color shifts Green -> Yellow -> Red
        Color fillColor = (displayedT > 0.5f)
            ? Color.Lerp(Color.yellow, Color.green, (displayedT - 0.5f) * 2f)
            : Color.Lerp(Color.red, Color.yellow, displayedT * 2f);

        ApplySciFiColor(fillRenderer, mpbFill, fillColor, glowStrength);

        // Stable billboard (no LookRotation jitter)
        if (billboardToCamera && Camera.main != null)
        {
            holder.rotation = Camera.main.transform.rotation;
        }
    }

    void CreateBar()
    {
        holder = new GameObject("HealthBar").transform;
        holder.SetParent(transform, false);
        holder.localPosition = offset;

        // Background (slightly behind fill to prevent z-fighting)
        barBack = GameObject.CreatePrimitive(PrimitiveType.Cube).transform;
        barBack.name = "Back";
        barBack.SetParent(holder, false);
        barBack.localPosition = new Vector3(0f, 0f, +0.001f);
        barBack.localScale = new Vector3(width, height, depth);

        // Fill (slightly in front)
        barFill = GameObject.CreatePrimitive(PrimitiveType.Cube).transform;
        barFill.name = "Fill";
        barFill.SetParent(holder, false);
        barFill.localPosition = new Vector3(0f, 0f, -0.001f);
        barFill.localScale = new Vector3(width, height, depth);

        // Remove colliders
        Destroy(barBack.GetComponent<Collider>());
        Destroy(barFill.GetComponent<Collider>());

        backRenderer = barBack.GetComponent<Renderer>();
        fillRenderer = barFill.GetComponent<Renderer>();

        // Dark sci-fi plate
        ApplySciFiColor(backRenderer, mpbBack, new Color(0.02f, 0.02f, 0.05f), 0.0f);

        // Start fill color
        ApplySciFiColor(fillRenderer, mpbFill, Color.green, glowStrength);
    }

    void ApplySciFiColor(Renderer r, MaterialPropertyBlock block, Color baseColor, float emissionStrength)
    {
        if (r == null) return;

        r.GetPropertyBlock(block);
        block.SetColor(ColorID, baseColor);
        block.SetColor(EmissionID, baseColor * emissionStrength);
        r.SetPropertyBlock(block);
    }
}


==============================
FILE: CivilianSpawner.cs
==============================

using UnityEngine;

public class CivilianSpawner : MonoBehaviour
{
    [Header("Civilian Settings")]
    public GameObject civilianPrefab;
    public int teamID;
    public int civilianCount = 10;

    [Header("Spawn Area")]
    public Vector3 spawnArea = new Vector3(5f, 0f, 5f);

    void Start()
    {
        SpawnCivilians();
    }

    void SpawnCivilians()
    {
        for (int i = 0; i < civilianCount; i++)
        {
            Vector3 spawnPos = transform.position +
                new Vector3(
                    Random.Range(-spawnArea.x, spawnArea.x),
                    0.5f,
                    Random.Range(-spawnArea.z, spawnArea.z)
                );

            GameObject civ = Instantiate(civilianPrefab, spawnPos, Quaternion.identity);

            Civilian civScript = civ.GetComponent<Civilian>();
            if (civScript != null)
            {
                civScript.teamID = teamID;
            }
            TeamColorManager.Instance.ApplyTeamColor(civ, teamID);
        }
    }
}


==============================
FILE: Selectable.cs
==============================

using UnityEngine;

public class Selectable : MonoBehaviour
{
    [Tooltip("Optional visual ring GameObject to toggle on selection.")]
    public GameObject selectionRing;

    public void SetSelected(bool selected)
    {
        if (selectionRing != null)
            selectionRing.SetActive(selected);
    }
}


==============================
FILE: UnitCombatController.cs
==============================

// =============================================================
// UnitCombatController.cs (Updated for WeaponComponent + UI)
//
// DEPENDENCIES:
// - WeaponComponent:
//      * Handles firing, cooldowns, projectile spawning.
// - Attackable:
//      * Target interface (teamID, IsAlive, isCivilian).
// - DiplomacyManager:
//      * War/peace filtering via AreAtWar(teamA, teamB).
// - AIMilitary:
//      * Calls SetManualTarget() for focus fire.
// - UnitInspectorUI:
//      * Uses:
//          - GetTargetStatus()
//          - canAttackCivilians
//          - ToggleAttackCivilians()
//          - stance
//          - SetStance(CombatStance)
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you change how targeting works, keep GetTargetStatus() in sync so UI
//   doesn’t break silently.
// - If you add new stances, update CombatStance and any UI that manipulates it.
// =============================================================

using UnityEngine;

public class UnitCombatController : MonoBehaviour
{
    public enum CombatStance { Hold, Guard, Aggressive }

    [Header("Owner")]
    public int teamID;

    [Header("Weapon")]
    public WeaponComponent weapon;

    [Header("Target Rules")]
    public bool canAttackCivilians = false;

    [Header("Detection")]
    public LayerMask attackableLayers;

    [Header("Runtime")]
    public Attackable currentTarget;

    private bool hasManualTarget;

    void Awake()
    {
        if (weapon == null)
            weapon = GetComponent<WeaponComponent>();
    }

    void Update()
    {
        if (currentTarget == null || !IsValidTarget(currentTarget))
        {
            currentTarget = null;
            hasManualTarget = false;
        }

        if (!hasManualTarget)
            AcquireTarget();

        if (currentTarget == null || weapon == null)
            return;

        float dist = Vector3.Distance(transform.position, currentTarget.transform.position);
        if (dist > weapon.range)
            return;

        Vector3 toTarget = currentTarget.transform.position - transform.position;
        toTarget.y = 0f;
        if (toTarget.sqrMagnitude > 0.01f)
            transform.rotation = Quaternion.Slerp(
                transform.rotation,
                Quaternion.LookRotation(toTarget),
                Time.deltaTime * 10f
            );

        if (weapon.CanFire)
            weapon.FireAtTarget(currentTarget, teamID);
    }

    void AcquireTarget()
    {
        if (weapon == null) return;

        Collider[] hits = Physics.OverlapSphere(transform.position, weapon.range, attackableLayers);

        Attackable best = null;
        float bestDist = float.MaxValue;

        foreach (var hit in hits)
        {
            var atk = hit.GetComponentInParent<Attackable>();
            if (atk == null || !IsValidTarget(atk)) continue;

            float d = Vector3.Distance(transform.position, atk.transform.position);
            if (d < bestDist)
            {
                bestDist = d;
                best = atk;
            }
        }

        currentTarget = best;
    }

    bool IsValidTarget(Attackable a)
    {
        if (a == null || !a.IsAlive) return false;
        if (a.teamID == teamID) return false;
        if (a.isCivilian && !canAttackCivilians) return false;

        return DiplomacyManager.Instance == null ||
               DiplomacyManager.Instance.AreAtWar(teamID, a.teamID);
    }

    public void SetManualTarget(Attackable target)
    {
        if (!IsValidTarget(target)) return;
        currentTarget = target;
        hasManualTarget = true;
    }

    public void ClearManualTarget()
    {
        hasManualTarget = false;
        currentTarget = null;
    }

    public void SetStance(CombatStance newStance)
    {
        // (You can expand this later to change behaviour based on stance.)
        // For now, stance is informational + used by UI.
        // If you add stance-specific logic, keep UI + AI in sync.
        // e.g., Aggressive could increase search radius, Hold could disable AcquireTarget().
        // This is left simple for now.
        // NOTE: UnitInspectorUI relies on this existing.
        // (No extra logic required yet.)
        // If you add "Hold" logic, you might want:
        // if (newStance == CombatStance.Hold) ClearManualTarget();
        // etc.
        // Keeping it minimal for now.
        // --------------------------------
        // But we still store it:
        stance = newStance;
    }

    public CombatStance stance = CombatStance.Guard;

    public string GetTargetStatus()
    {
        if (currentTarget == null)
            return "None";

        return currentTarget.name + (hasManualTarget ? " (Ordered)" : "");
    }

    public void ToggleAttackCivilians()
    {
        canAttackCivilians = !canAttackCivilians;
    }
}

==============================
FILE: UnitCommandController.cs
==============================

// =============================================================
// UnitCommandController.cs
//
// DEPENDENCIES:
// - NavMeshAgent:
//      * Handles movement for move/defend/follow behaviours.
// - ICommandable (interface):
//      * Allows external systems (e.g., player input) to issue commands.
// - CombatStance (enum):
//      * This is a separate stance enum from UnitCombatController.CombatStance,
//        used for movement/command behaviour.
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you unify stances between movement and combat, consider merging the
//   CombatStance definitions or creating a shared enum.
// - If this is not used by your current input system, you can safely remove it.
// =============================================================

using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent))]
public class UnitCommandController : MonoBehaviour, ICommandable
{
    public CombatStance stance = CombatStance.Defend;

    [Header("Follow/Defend")]
    public Transform followTarget;
    public float defendRadius = 8f;

    private NavMeshAgent agent;
    private Vector3 defendAnchor;
    private bool hasDefendAnchor;

    void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
    }

    void Update()
    {
        if (stance == CombatStance.FollowTarget && followTarget != null)
        {
            agent.SetDestination(followTarget.position);
        }
        else if (stance == CombatStance.Defend)
        {
            if (!hasDefendAnchor)
            {
                defendAnchor = transform.position;
                hasDefendAnchor = true;
            }

            float d = (transform.position - defendAnchor).sqrMagnitude;
            if (d > defendRadius * defendRadius)
                agent.SetDestination(defendAnchor);
        }
    }

    public void IssueMove(Vector3 worldPos)
    {
        stance = CombatStance.TakePoint;
        followTarget = null;
        hasDefendAnchor = false;
        agent.SetDestination(worldPos);
    }

    public void SetDefendHere()
    {
        stance = CombatStance.Defend;
        followTarget = null;
        defendAnchor = transform.position;
        hasDefendAnchor = true;
    }

    public void SetFollow(Transform target)
    {
        stance = CombatStance.FollowTarget;
        followTarget = target;
        hasDefendAnchor = false;
    }

    public void ClearFollow()
    {
        if (stance == CombatStance.FollowTarget)
            stance = CombatStance.Defend;

        followTarget = null;
        hasDefendAnchor = false;
    }
}

==============================
FILE: UnitProductionQueue.cs
==============================

// ============================================================================
// UnitProductionQueue.cs
//
// PURPOSE:
// - Handles timed production of units inside Barracks or other production buildings.
// - Maintains a FIFO queue of production tasks.
// - Notifies Barracks when a unit is finished.
//
// DEPENDENCIES:
// - UnitProductionDefinition:
//      * Provides buildTime, unitPrefab, costs.
// - Barracks:
//      * Owns this component.
//      * Calls Enqueue(), CancelLast().
//      * Subscribes to OnUnitCompleted to spawn units.
// - UnitInspectorUI:
//      * Reads Progress01, CurrentBuildTime, QueueCount.
// - TeamResources / TeamStorageManager:
//      * Costs are spent BEFORE enqueueing (handled by Barracks).
//
// NOTES FOR FUTURE MAINTENANCE:
// - If you add production speed modifiers (tech, upgrades, buffs), apply them to timeRemaining.
// - If you add parallel production (multiple queues), split into multiple lanes.
// - If you add UI showing the full queue, expose queue contents safely.
// - If you add unit categories (infantry, vehicles), consider separate queues.
// - If you add cancel refunds, integrate with TeamResources.
//
// INSPECTOR REQUIREMENTS:
// - None; this component is created automatically by Barracks if missing.
// ============================================================================

using System.Collections.Generic;
using UnityEngine;

public class UnitProductionQueue : MonoBehaviour
{
    class QueueItem
    {
        public UnitProductionDefinition def;
        public float timeRemaining;
    }

    private readonly List<QueueItem> queue = new List<QueueItem>();
    private QueueItem current;

    public System.Action<UnitProductionDefinition> OnUnitCompleted;

    void Update()
    {
        if (current == null && queue.Count > 0)
            current = queue[0];

        if (current == null) return;

        current.timeRemaining -= Time.deltaTime;

        if (current.timeRemaining <= 0f)
        {
            OnUnitCompleted?.Invoke(current.def);
            queue.RemoveAt(0);
            current = null;
        }
    }

    public void Enqueue(UnitProductionDefinition def)
    {
        if (def == null) return;

        queue.Add(new QueueItem
        {
            def = def,
            timeRemaining = def.buildTime
        });
    }

    public void CancelLast()
    {
        if (queue.Count == 0) return;

        if (queue[0] == current)
            current = null;

        queue.RemoveAt(queue.Count - 1);
    }

    public bool IsBuilding => current != null;

    public float Progress01 =>
        current == null ? 0f : 1f - (current.timeRemaining / current.def.buildTime);

    public float CurrentBuildTime =>
        current == null ? 0f : current.def.buildTime;

    public int QueueCount => queue.Count;
}

==============================
FILE: FindTeamDuplicates.cs
==============================

using UnityEngine;
using UnityEditor;
using System.Linq;

public class FindTeamDuplicates : MonoBehaviour
{
    [MenuItem("Tools/Find Team Duplicates")]
    static void FindTeams()
    {
        var scripts = Resources.FindObjectsOfTypeAll<MonoScript>()
            .Where(s => s != null && s.text.Contains("class Team"))
            .ToArray();

        foreach (var s in scripts)
            Debug.Log("FOUND TEAM CLASS IN: " + AssetDatabase.GetAssetPath(s));
    }
}

==============================
FILE: TeamWatchdog.cs
==============================

using UnityEngine;

public class TeamWatchdog : MonoBehaviour
{
    void OnDestroy()
    {
        Debug.LogError($"TEAM DESTROYED: {gameObject.name}", this);
    }
}

==============================
FILE: ParentRenamer.cs
==============================

using UnityEngine;

public class ParentRenamer : MonoBehaviour
{
    // The list of offensive words as a string array
    private string[] offensiveWords = new string[]
    {
        "cunt", "motherfucker", "fuck", "bitch", "shit", "bastard", "cock", "twat", "nigger", "faggot",
        "kike", "wanker", "asshole", "piss", "damn", "retard", "idiot", "arse", "arsehole", "bollocks",
        "bloody", "dick", "prick", "penis", "frigging", "slapper", "dork", "nonce", "tits", "moron",
        "cretin", "negro", "coon", "pikey", "gippo", "golliwog", "spastic", "schizo", "paki", "cocksucker",
        "dyke", "anus", "ass-hat", "ass-jabber", "ass-pirate", "assbag", "assbandit", "assbanger", "assbite", "assclown",
        "asscock", "asscracker", "asses", "assface", "assfuck", "assfucker", "assgoblin", "asshat", "asshead", "asshopper",
        "assjacker", "asslick", "asslicker", "assmonkey", "assmunch", "assmuncher", "assnigger", "asspirate", "assshit", "assshole",
        "asssucker", "asswad", "asswipe", "axwound", "goddammit", "dick-head", "dumb-ass", "goddamned", "mother-fucker", "father-fucker",
        "goddamnit", "jackarse", "abbo", "abo", "anal", "analsex", "arab", "argie", "asian", "assassin",
        "assassinate", "assault", "assbagger", "assblaster", "asscowboy", "asshore", "assjockey", "asskiss", "asskisser", "assklown"
    };

    void Awake()
    {
        // Ensure this runs early, before Start() on other scripts
        RenameParent();
    }

    private void RenameParent()
    {
        Transform parentTransform = transform.parent;
        if (parentTransform != null)
        {
            // Pick two random words (can be the same)
            int firstNameIndex = Random.Range(0, offensiveWords.Length);
            int lastNameIndex = Random.Range(0, offensiveWords.Length);

            string firstName = offensiveWords[firstNameIndex];
            string lastName = offensiveWords[lastNameIndex];

            // Set parent's name to "First Last"
            parentTransform.name = firstName + " " + lastName;

            // Optional: Log for debugging
            Debug.Log($"Renamed parent '{parentTransform.name}' (was '{parentTransform.gameObject.name}') from child '{gameObject.name}'");
        }
        else
        {
            Debug.LogWarning("ParentRenamer: No parent found on " + gameObject.name + ". Skipping rename.");
        }
    }
}

==============================
FILE: SelfRenamer.cs
==============================

using UnityEngine;

public class SelfRenamer : MonoBehaviour
{
    // The list of offensive words as a string array
    private string[] offensiveWords = new string[]
    {
        "Cunt", "Motherfucker", "Fuck", "Bitch", "Shit", "bastard", "cock", "twat", "nigger", "faggot",
        "kike", "wanker", "asshole", "piss", "damn", "retard", "idiot", "arse", "arsehole", "bollocks",
        "bloody", "dick", "prick", "penis", "frigging", "slapper", "dork", "nonce", "tits", "moron",
        "cretin", "negro", "coon", "pikey", "gippo", "golliwog", "spastic", "schizo", "paki", "cocksucker",
        "dyke", "anus", "ass-hat", "ass-jabber", "ass-pirate", "assbag", "assbandit", "assbanger", "assbite", "assclown",
        "asscock", "asscracker", "asses", "assface", "assfuck", "assfucker", "assgoblin", "asshat", "asshead", "asshopper",
        "assjacker", "asslick", "asslicker", "assmonkey", "assmunch", "assmuncher", "assnigger", "asspirate", "assshit", "assshole",
        "asssucker", "asswad", "asswipe", "axwound", "goddammit", "dick-head", "dumb-ass", "goddamned", "mother-fucker", "father-fucker",
        "goddamnit", "jackarse", "abbo", "abo", "anal", "analsex", "arab", "argie", "asian", "assassin",
        "assassinate", "assault", "assbagger", "assblaster", "asscowboy", "asshore", "assjockey", "asskiss", "asskisser", "assklown"
    };

    void Awake()
    {
        // Runs early, before Start() on other scripts
        RenameSelf();
    }

    private void RenameSelf()
    {
        // Pick two random words (can be the same)
        int firstNameIndex = Random.Range(0, offensiveWords.Length);
        int lastNameIndex = Random.Range(0, offensiveWords.Length);

        string firstName = offensiveWords[firstNameIndex];
        string lastName = offensiveWords[lastNameIndex];

        // Set this GameObject's name to "First Last"
        gameObject.name = firstName + " " + lastName;

        // Optional: Log for debugging
        Debug.Log($"Renamed self to '{gameObject.name}'");
    }
}

==============================
FILE: TeamColorUtils.cs
==============================

using UnityEngine;

public static class TeamColorUtils
{
    static readonly Color[] colors =
    {
        Color.blue,
        Color.red,
        Color.green,
        Color.magenta,
        Color.cyan,
        Color.gray
    };

    public static Color Get(int teamID)
    {
        if (teamID < 0 || teamID >= colors.Length)
            return Color.white;

        return colors[teamID];
    }
}
